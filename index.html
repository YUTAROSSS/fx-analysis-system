<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FX通貨ペア分析システム</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        :root {
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --success-color: #28a745;
            --danger-color: #dc3545;
            --warning-color: #ffc107;
            --info-color: #17a2b8;
            --light-color: #f8f9fa;
            --dark-color: #343a40;
            --background-color: #ffffff;
            --text-color: #333333;
            --border-color: #dee2e6;
            --shadow: 0 2px 10px rgba(0,0,0,0.1);
            --border-radius: 8px;
            --transition: all 0.3s ease;
        }

        [data-theme="dark"] {
            --background-color: #1a1a1a;
            --text-color: #e0e0e0;
            --border-color: #444444;
            --light-color: #2d2d2d;
            --shadow: 0 2px 10px rgba(0,0,0,0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
            transition: var(--transition);
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: linear-gradient(135deg, var(--primary-color), var(--info-color));
            color: white;
            padding: 20px 0;
            margin-bottom: 30px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
        }

        .header-content {
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: wrap;
            gap: 15px;
        }

        .header h1 {
            font-size: 2rem;
            font-weight: 700;
            margin: 0;
        }

        .header-controls {
            display: flex;
            gap: 10px;
            align-items: center;
            flex-wrap: wrap;
        }

        .usage-display {
            display: flex;
            gap: 20px;
            align-items: center;
            background: rgba(255,255,255,0.1);
            padding: 10px 15px;
            border-radius: var(--border-radius);
            font-size: 0.9rem;
        }

        .usage-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .usage-item label {
            font-size: 0.8rem;
            opacity: 0.9;
        }

        .usage-progress {
            width: 80px;
            height: 8px;
            border-radius: 4px;
            background: rgba(255,255,255,0.2);
            overflow: hidden;
        }

        .usage-progress::-webkit-progress-bar {
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
        }

        .usage-progress::-webkit-progress-value {
            background: #28a745;
            border-radius: 4px;
            transition: background-color 0.3s ease;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            text-decoration: none;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            transition: var(--transition);
            background: var(--secondary-color);
            color: white;
        }

        .btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow);
        }

        .btn-primary {
            background: var(--primary-color);
        }

        .btn-success {
            background: var(--success-color);
        }

        .btn-danger {
            background: var(--danger-color);
        }

        .btn-warning {
            background: var(--warning-color);
            color: var(--dark-color);
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 12px;
        }

        .currency-section {
            background: var(--light-color);
            padding: 25px;
            border-radius: var(--border-radius);
            margin-bottom: 30px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
        }

        .section-title {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: var(--primary-color);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .currency-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 20px;
        }

        .currency-btn {
            background: var(--secondary-color);
            color: white;
            border: none;
            padding: 12px 18px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 500;
            min-width: 80px;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .currency-btn:hover {
            background: var(--primary-color);
            transform: translateY(-2px);
        }

        .currency-btn.active {
            background: var(--primary-color);
            box-shadow: 0 0 20px rgba(0,123,255,0.3);
        }

        .currency-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .currency-btn:hover::before {
            left: 100%;
        }

        .currency-controls {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        .current-pair {
            font-size: 1.8rem;
            font-weight: 700;
            color: var(--primary-color);
            text-align: center;
            margin: 20px 0;
            padding: 15px;
            background: linear-gradient(135deg, rgba(0,123,255,0.1), rgba(23,162,184,0.1));
            border-radius: var(--border-radius);
            border: 2px solid var(--primary-color);
        }

        .scenarios-section {
            background: var(--light-color);
            padding: 25px;
            border-radius: var(--border-radius);
            margin-bottom: 30px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
        }

        .scenario-controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            align-items: center;
            margin-bottom: 20px;
        }

        .scenario-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            flex: 1;
        }

        .scenario-item {
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 5px;
        }

        .scenario-btn {
            background: var(--secondary-color);
            color: white;
            border: none;
            padding: 12px 18px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 500;
            min-width: 100px;
            transition: var(--transition);
            position: relative;
        }

        .scenario-btn:hover {
            background: var(--primary-color);
            transform: translateY(-2px);
        }

        .scenario-btn.active {
            background: var(--primary-color);
            box-shadow: 0 0 20px rgba(0,123,255,0.3);
        }

        .status-indicator {
            font-size: 0.7rem;
            padding: 2px 6px;
            background: rgba(0,0,0,0.1);
            border-radius: 10px;
            white-space: nowrap;
            min-height: 18px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .analysis-section {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .status-section, .wave-section {
            background: var(--light-color);
            padding: 25px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
        }

        .status-buttons, .wave-buttons {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
        }

        .status-btn, .wave-btn {
            background: var(--light-color);
            color: var(--text-color);
            border: 2px solid var(--border-color);
            padding: 10px 16px;
            border-radius: var(--border-radius);
            cursor: pointer;
            font-weight: 500;
            transition: var(--transition);
            min-width: 80px;
            text-align: center;
        }

        .status-btn:hover, .wave-btn:hover {
            border-color: var(--primary-color);
            background: rgba(0,123,255,0.1);
        }

        .status-btn.active, .wave-btn.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }

        .status-btn[data-status="実戦"].active {
            background: var(--success-color);
            border-color: var(--success-color);
        }

        .status-btn[data-status="利確"].active {
            background: var(--success-color);
            border-color: var(--success-color);
        }

        .status-btn[data-status="損切り"].active {
            background: var(--danger-color);
            border-color: var(--danger-color);
        }

        .images-section {
            background: var(--light-color);
            padding: 25px;
            border-radius: var(--border-radius);
            margin-bottom: 30px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
        }

        .image-areas {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-top: 20px;
        }

        .image-area {
            border: 2px dashed var(--border-color);
            border-radius: var(--border-radius);
            padding: 20px;
            text-align: center;
            min-height: 200px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            transition: var(--transition);
            position: relative;
            background: var(--background-color);
        }

        .image-area:hover {
            border-color: var(--primary-color);
            background: rgba(0,123,255,0.05);
        }

        .image-area.drag-over {
            border-color: var(--success-color);
            background: rgba(40,167,69,0.1);
        }

        .image-preview {
            max-width: 100%;
            max-height: 300px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            margin-bottom: 10px;
        }

        .image-controls {
            display: flex;
            gap: 8px;
            margin-top: 10px;
        }

        .memo-section {
            background: var(--light-color);
            padding: 25px;
            border-radius: var(--border-radius);
            margin-bottom: 30px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
        }

        .memo-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .memo-textarea {
            width: 100%;
            min-height: 200px;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-family: inherit;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
            background: var(--background-color);
            color: var(--text-color);
            transition: var(--transition);
        }

        .memo-textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
        }

        .prompt-section {
            background: var(--light-color);
            padding: 25px;
            border-radius: var(--border-radius);
            margin-bottom: 30px;
            box-shadow: var(--shadow);
            border: 1px solid var(--border-color);
        }

        .prompt-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .prompt-textarea {
            width: 100%;
            min-height: 120px;
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-family: inherit;
            font-size: 14px;
            line-height: 1.6;
            resize: vertical;
            background: var(--background-color);
            color: var(--text-color);
            transition: var(--transition);
        }

        .prompt-textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
        }

        .navigation {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 100;
        }

        .nav-btn {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            border: none;
            background: var(--primary-color);
            color: white;
            font-size: 18px;
            cursor: pointer;
            box-shadow: var(--shadow);
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .nav-btn:hover {
            background: var(--info-color);
            transform: scale(1.1);
        }

        .history-sidebar {
            position: fixed;
            top: 0;
            right: -400px;
            width: 400px;
            height: 100vh;
            background: var(--background-color);
            border-left: 1px solid var(--border-color);
            box-shadow: -5px 0 15px rgba(0,0,0,0.1);
            z-index: 1000;
            transition: right 0.3s ease;
            overflow-y: auto;
        }

        .history-header {
            padding: 20px;
            background: var(--primary-color);
            color: white;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .history-content {
            padding: 20px;
        }

        .history-search {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            background: var(--background-color);
            color: var(--text-color);
        }

        .history-item {
            padding: 15px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            margin-bottom: 10px;
            cursor: pointer;
            transition: var(--transition);
            background: var(--light-color);
        }

        .history-item:hover {
            background: rgba(0,123,255,0.1);
            border-color: var(--primary-color);
        }

        .history-item-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .history-item-title {
            font-weight: 600;
            color: var(--primary-color);
        }

        .history-item-date {
            font-size: 0.8rem;
            color: var(--secondary-color);
        }

        .history-item-preview {
            font-size: 0.9rem;
            color: var(--text-color);
            line-height: 1.4;
            max-height: 60px;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .error-bar {
            position: fixed;
            top: -100px;
            left: 0;
            right: 0;
            background: var(--danger-color);
            color: white;
            padding: 15px 20px;
            box-shadow: var(--shadow);
            z-index: 2000;
            transition: top 0.3s ease;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .error-bar.show {
            top: 0;
        }

        .error-message {
            flex: 1;
            margin-right: 15px;
        }

        .error-actions {
            display: flex;
            gap: 10px;
        }

        .success-bar {
            position: fixed;
            top: -100px;
            left: 0;
            right: 0;
            background: var(--success-color);
            color: white;
            padding: 15px 20px;
            box-shadow: var(--shadow);
            z-index: 2000;
            transition: top 0.3s ease;
            text-align: center;
        }

        .success-bar.show {
            top: 0;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            opacity: 0;
            visibility: hidden;
            transition: var(--transition);
        }

        .loading-overlay.show {
            opacity: 1;
            visibility: visible;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 5px solid rgba(255,255,255,0.3);
            border-top: 5px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .file-input {
            display: none;
        }

        .drop-zone {
            border: 2px dashed var(--border-color);
            border-radius: var(--border-radius);
            padding: 40px 20px;
            text-align: center;
            cursor: pointer;
            transition: var(--transition);
            background: var(--background-color);
        }

        .drop-zone:hover {
            border-color: var(--primary-color);
            background: rgba(0,123,255,0.05);
        }

        .drop-zone.dragover {
            border-color: var(--success-color);
            background: rgba(40,167,69,0.1);
        }

        .modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0,0,0,0.5);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
        }

        .modal-content {
            background: var(--background-color);
            padding: 30px;
            border-radius: var(--border-radius);
            max-width: 500px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: var(--primary-color);
        }

        .close-btn {
            background: none;
            border: none;
            font-size: 24px;
            cursor: pointer;
            color: var(--secondary-color);
            padding: 0;
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .close-btn:hover {
            color: var(--danger-color);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: var(--text-color);
        }

        .form-input {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color);
            border-radius: var(--border-radius);
            font-size: 14px;
            background: var(--background-color);
            color: var(--text-color);
            transition: var(--transition);
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(0,123,255,0.1);
        }

        .modal-actions {
            display: flex;
            gap: 10px;
            justify-content: flex-end;
            margin-top: 20px;
        }

        @media (max-width: 768px) {
            .container {
                padding: 10px;
            }

            .header h1 {
                font-size: 1.5rem;
            }

            .header-content {
                flex-direction: column;
                text-align: center;
            }

            .usage-display {
                flex-direction: column;
                gap: 15px;
            }

            .analysis-section {
                grid-template-columns: 1fr;
                gap: 20px;
            }

            .image-areas {
                grid-template-columns: 1fr;
            }

            .currency-buttons, .scenario-buttons {
                justify-content: center;
            }

            .scenario-controls {
                flex-direction: column;
                align-items: stretch;
            }

            .scenario-buttons {
                justify-content: center;
            }

            .status-buttons, .wave-buttons {
                justify-content: center;
            }

            .memo-controls, .prompt-controls {
                justify-content: center;
            }

            .navigation {
                bottom: 10px;
                right: 10px;
            }

            .history-sidebar {
                width: 100%;
                right: -100%;
            }

            .modal-content {
                margin: 20px;
                width: calc(100% - 40px);
            }
        }

        @media (max-width: 480px) {
            .currency-btn, .scenario-btn {
                min-width: 70px;
                padding: 10px 12px;
                font-size: 13px;
            }

            .status-btn, .wave-btn {
                min-width: 70px;
                padding: 8px 12px;
                font-size: 12px;
            }

            .btn {
                padding: 8px 16px;
                font-size: 13px;
            }

            .section-title {
                font-size: 1.2rem;
            }

            .current-pair {
                font-size: 1.5rem;
            }
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .slide-in {
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .pulse {
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }

        .shake {
            animation: shake 0.5s ease-in-out;
        }

        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            25% { transform: translateX(-5px); }
            75% { transform: translateX(5px); }
        }

        .highlight {
            background: linear-gradient(135deg, rgba(255,193,7,0.2), rgba(255,193,7,0.1));
            border: 1px solid var(--warning-color);
            animation: highlight 1s ease-in-out;
        }

        @keyframes highlight {
            0% { background: rgba(255,193,7,0.4); }
            100% { background: rgba(255,193,7,0.1); }
        }

        .tooltip {
            position: relative;
            display: inline-block;
        }

        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background: var(--dark-color);
            color: white;
            padding: 8px 12px;
            border-radius: var(--border-radius);
            font-size: 12px;
            white-space: nowrap;
            opacity: 0;
            visibility: hidden;
            transition: var(--transition);
            z-index: 1000;
        }

        .tooltip::before {
            content: '';
            position: absolute;
            bottom: 115%;
            left: 50%;
            transform: translateX(-50%);
            border: 5px solid transparent;
            border-top-color: var(--dark-color);
            opacity: 0;
            visibility: hidden;
            transition: var(--transition);
        }

        .tooltip:hover::after,
        .tooltip:hover::before {
            opacity: 1;
            visibility: visible;
        }

        .status-indicator.status-実戦 {
            background: var(--success-color);
            color: white;
        }

        .status-indicator.status-利確 {
            background: var(--success-color);
            color: white;
        }

        .status-indicator.status-損切り {
            background: var(--danger-color);
            color: white;
        }

        .status-indicator.status-計算中 {
            background: var(--warning-color);
            color: var(--dark-color);
        }

        .status-indicator.status-検討中 {
            background: var(--info-color);
            color: white;
        }

        .status-indicator.status-見送り {
            background: var(--secondary-color);
            color: white;
        }

        .drag-handle {
            cursor: grab;
            padding: 5px;
            color: var(--secondary-color);
        }

        .drag-handle:active {
            cursor: grabbing;
        }

        .scenario-item.dragging {
            opacity: 0.5;
            transform: rotate(5deg);
        }

        .scenario-item.drag-over {
            border: 2px dashed var(--primary-color);
            background: rgba(0,123,255,0.1);
        }

        .image-upload-progress {
            width: 100%;
            height: 4px;
            background: var(--light-color);
            border-radius: 2px;
            overflow: hidden;
            margin-top: 10px;
        }

        .image-upload-progress-bar {
            height: 100%;
            background: var(--success-color);
            width: 0%;
            transition: width 0.3s ease;
        }

        .connection-status {
            position: fixed;
            top: 10px;
            left: 10px;
            padding: 8px 12px;
            border-radius: 20px;
            font-size: 12px;
            font-weight: 500;
            z-index: 1000;
            transition: var(--transition);
        }

        .connection-status.online {
            background: var(--success-color);
            color: white;
        }

        .connection-status.offline {
            background: var(--danger-color);
            color: white;
        }

        .auto-save-indicator {
            position: fixed;
            bottom: 10px;
            left: 10px;
            padding: 8px 12px;
            border-radius: var(--border-radius);
            font-size: 12px;
            background: var(--success-color);
            color: white;
            opacity: 0;
            visibility: hidden;
            transition: var(--transition);
            z-index: 1000;
        }

        .auto-save-indicator.show {
            opacity: 1;
            visibility: visible;
        }

        .keyboard-shortcut-hint {
            font-size: 0.7rem;
            color: var(--secondary-color);
            margin-left: 5px;
            opacity: 0.7;
        }

        .theme-toggle {
            position: relative;
            width: 60px;
            height: 30px;
            background: var(--secondary-color);
            border-radius: 15px;
            cursor: pointer;
            transition: var(--transition);
            border: none;
            outline: none;
        }

        .theme-toggle::before {
            content: '🌙';
            position: absolute;
            top: 3px;
            left: 3px;
            width: 24px;
            height: 24px;
            background: white;
            border-radius: 50%;
            transition: var(--transition);
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 12px;
        }

        [data-theme="dark"] .theme-toggle {
            background: var(--primary-color);
        }

        [data-theme="dark"] .theme-toggle::before {
            content: '☀️';
            transform: translateX(30px);
        }

        .backup-status {
            padding: 10px;
            border-radius: var(--border-radius);
            margin: 10px 0;
            font-size: 0.9rem;
        }

        .backup-status.success {
            background: rgba(40,167,69,0.1);
            border: 1px solid var(--success-color);
            color: var(--success-color);
        }

        .backup-status.error {
            background: rgba(220,53,69,0.1);
            border: 1px solid var(--danger-color);
            color: var(--danger-color);
        }

        .backup-status.info {
            background: rgba(23,162,184,0.1);
            border: 1px solid var(--info-color);
            color: var(--info-color);
        }
    </style>
</head>
<body>
    <div class="connection-status online" id="connection-status">🟢 オンライン</div>
    <div class="auto-save-indicator" id="auto-save-indicator">💾 自動保存完了</div>

    <div class="error-bar" id="error-bar">
        <div class="error-message" id="error-message"></div>
        <div class="error-actions">
            <button class="btn btn-sm" id="recovery-btn">復旧</button>
            <button class="close-btn" onclick="hideError()">×</button>
        </div>
    </div>

    <div class="success-bar" id="success-bar">
        <div id="success-message"></div>
    </div>

    <div class="loading-overlay" id="loading-overlay">
        <div class="loading-spinner"></div>
    </div>

    <div class="container">
        <header class="header">
            <div class="container">
                <div class="header-content">
                    <h1>📊 FX通貨ペア分析システム</h1>
                    <div class="header-controls">
                        <div class="usage-display">
                            <div class="usage-item">
                                <label>データベース</label>
                                <progress class="usage-progress" id="db-usage" value="0" max="100"></progress>
                                <span id="db-percent">0%</span>
                            </div>
                            <div class="usage-item">
                                <label>ストレージ</label>
                                <progress class="usage-progress" id="storage-usage" value="0" max="100"></progress>
                                <span id="storage-percent">0%</span>
                            </div>
                        </div>
                        <button class="theme-toggle" id="theme-toggle" title="ダークモード切り替え (Ctrl+D)"></button>
                        <button class="btn btn-success" id="backup-btn" title="バックアップ作成 (Ctrl+Shift+S)">
                            💾 バックアップ
                        </button>
                        <button class="btn btn-primary" id="history-btn" title="履歴表示 (Ctrl+H)">
                            📚 履歴
                        </button>
                    </div>
                </div>
            </div>
        </header>

        <section class="currency-section fade-in">
            <h2 class="section-title">
                🌍 通貨ペア選択
                <span class="keyboard-shortcut-hint">Ctrl+Left/Right: 前後移動</span>
            </h2>
            <div class="currency-buttons">
                <button class="currency-btn active" data-currency="USDJPY">USDJPY</button>
                <button class="currency-btn" data-currency="EURUSD">EURUSD</button>
                <button class="currency-btn" data-currency="GBPUSD">GBPUSD</button>
                <button class="currency-btn" data-currency="AUDUSD">AUDUSD</button>
                <button class="currency-btn" data-currency="SILVER">SILVER</button>
                <button class="currency-btn" data-currency="GOLD">GOLD</button>
            </div>
            <div class="currency-controls">
                <button class="btn btn-primary" id="add-currency">➕ 通貨ペア追加</button>
                <button class="btn btn-danger" id="remove-currency">🗑️ 通貨ペア削除</button>
            </div>
        </section>

        <div class="current-pair" id="current-pair">USDJPY</div>

        <section class="scenarios-section fade-in">
            <h2 class="section-title">
                📋 シナリオ管理
                <span class="keyboard-shortcut-hint">Ctrl+N: 新規追加</span>
            </h2>
            <div class="scenario-controls">
                <div class="scenario-buttons" id="scenario-buttons">
                    <div class="scenario-item">
                        <button class="scenario-btn active" data-scenario="scenario1">
                            <span class="drag-handle">⋮⋮</span>
                            シナリオ1
                        </button>
                        <div class="status-indicator">📊 未設定</div>
                    </div>
                    <div class="scenario-item">
                        <button class="scenario-btn" data-scenario="scenario2">
                            <span class="drag-handle">⋮⋮</span>
                            シナリオ2
                        </button>
                        <div class="status-indicator">📊 未設定</div>
                    </div>
                    <div class="scenario-item">
                        <button class="scenario-btn" data-scenario="scenario3">
                            <span class="drag-handle">⋮⋮</span>
                            シナリオ3
                        </button>
                        <div class="status-indicator">📊 未設定</div>
                    </div>
                </div>
                <div class="scenario-actions">
                    <button class="btn btn-primary" id="add-scenario">➕ シナリオ追加</button>
                    <button class="btn btn-danger" id="remove-scenario">🗑️ シナリオ削除</button>
                </div>
            </div>
        </section>

        <div class="analysis-section">
            <section class="status-section">
                <h3 class="section-title">📈 分析ステータス</h3>
                <div class="status-buttons">
                    <button class="status-btn" data-status="検討中">🤔 検討中</button>
                    <button class="status-btn" data-status="計算中">🔄 計算中</button>
                    <button class="status-btn" data-status="実戦">⚡ 実戦</button>
                    <button class="status-btn" data-status="利確">📈 利確</button>
                    <button class="status-btn" data-status="損切り">📉 損切り</button>
                    <button class="status-btn" data-status="見送り">👀 見送り</button>
                </div>
            </section>

            <section class="wave-section">
                <h3 class="section-title">🌊 狙う波</h3>
                <div class="wave-buttons">
                    <button class="wave-btn" data-wave="1波">1波</button>
                    <button class="wave-btn" data-wave="2波">2波</button>
                    <button class="wave-btn" data-wave="3波">3波</button>
                    <button class="wave-btn" data-wave="4波">4波</button>
                    <button class="wave-btn" data-wave="5波">5波</button>
                    <button class="wave-btn" data-wave="A波">A波</button>
                    <button class="wave-btn" data-wave="B波">B波</button>
                    <button class="wave-btn" data-wave="C波">C波</button>
                </div>
            </section>
        </div>

        <section class="images-section fade-in">
            <h2 class="section-title">🖼️ チャート画像</h2>
            <div class="image-areas">
                <div class="image-area" id="image-area-1">
                    <div class="drop-zone" data-area="1">
                        <p>📷 画像をドラッグ&ドロップ<br>または<br>クリックして選択</p>
                        <input type="file" class="file-input" id="file-input-1" accept="image/*" multiple>
                        <div class="image-upload-progress" style="display: none;">
                            <div class="image-upload-progress-bar"></div>
                        </div>
                    </div>
                </div>
                <div class="image-area" id="image-area-2">
                    <div class="drop-zone" data-area="2">
                        <p>📷 画像をドラッグ&ドロップ<br>または<br>クリックして選択</p>
                        <input type="file" class="file-input" id="file-input-2" accept="image/*" multiple>
                        <div class="image-upload-progress" style="display: none;">
                            <div class="image-upload-progress-bar"></div>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <section class="memo-section fade-in">
            <h2 class="section-title">
                📝 分析メモ
                <span class="keyboard-shortcut-hint">Ctrl+S: 手動保存</span>
            </h2>
            <div class="memo-controls">
                <button class="btn btn-primary" id="copy-memo" title="メモをコピー (Ctrl+C)">
                    📋 コピー
                </button>
            </div>
            <textarea 
                class="memo-textarea" 
                id="analysis-memo" 
                placeholder="ここに分析内容を入力してください...&#10;&#10;例：&#10;- 現在の相場状況&#10;- エントリーポイント&#10;- 利確・損切りライン&#10;- リスク管理方針"
            ></textarea>
        </section>

        <section class="prompt-section fade-in">
            <h2 class="section-title">🤖 固定プロンプト</h2>
            <div class="prompt-controls">
                <button class="btn btn-primary" id="copy-prompt" title="プロンプトをコピー">
                    📋 コピー
                </button>
                <button class="btn btn-warning" id="change-prompt">
                    ✏️ 変更
                </button>
                <button class="btn btn-success" id="chatgpt-analysis">
                    🚀 ChatGPT分析
                </button>
            </div>
            <textarea 
                class="prompt-textarea" 
                id="fixed-prompt" 
                placeholder="ChatGPT用の固定プロンプトを入力してください..."
            >あなたはプロのFXトレーダーです。以下の分析内容を基に、具体的なトレード戦略を提案してください。

分析観点：
1. テクニカル分析の妥当性
2. リスク管理の適切性
3. エントリー・エグジット戦略
4. 相場環境との整合性

回答形式：
- 推奨アクション
- 根拠
- リスク要因
- 代替シナリオ</textarea>
        </section>
    </div>

    <div class="navigation">
        <button class="nav-btn tooltip" id="top-return" data-tooltip="トップに戻る (Ctrl+Home)" title="トップに戻る">
            🔝
        </button>
        <button class="nav-btn tooltip" id="prev-chart" data-tooltip="前のシナリオ" title="前のシナリオ">
            ⬅️
        </button>
        <button class="nav-btn tooltip" id="next-chart" data-tooltip="次のシナリオ" title="次のシナリオ">
            ➡️
        </button>
    </div>

    <div class="history-sidebar" id="history-sidebar">
        <div class="history-header">
            <h3>📚 履歴</h3>
            <button class="close-btn" id="close-history">×</button>
        </div>
        <div class="history-content">
            <input type="text" class="history-search" id="history-search" placeholder="🔍 履歴を検索...">
            <div id="history-list">
                <!-- 履歴アイテムが動的に追加される -->
            </div>
        </div>
    </div>

    <script>
        // Supabase設定
        const SUPABASE_URL = 'https://your-supabase-url.supabase.co';
        const SUPABASE_ANON_KEY = 'your-supabase-anon-key';

        // グローバル変数
        let app = null;
        let isInitializing = false;

        // ユーティリティ関数
        function safeGetElement(id) {
            try {
                return document.getElementById(id);
            } catch (error) {
                console.warn(`要素取得エラー: ${id}`, error);
                return null;
            }
        }

        function safeUpdateElement(id, content) {
            try {
                const element = safeGetElement(id);
                if (element) {
                    element.textContent = content;
                    return true;
                }
                return false;
            } catch (error) {
                console.warn(`要素更新エラー: ${id}`, error);
                return false;
            }
        }

        function validateInput(input, type, required = false) {
            if (required && (!input || input.trim() === '')) {
                throw new Error(`${type}は必須です`);
            }
            
            if (input) {
                switch (type) {
                    case 'currency':
                        if (!/^[A-Z]{3,8}$/.test(input.trim())) {
                            throw new Error('通貨ペアは3-8文字の大文字英数字で入力してください');
                        }
                        break;
                    case 'scenario':
                        if (!/^[a-zA-Z0-9_-]+$/.test(input.trim())) {
                            throw new Error('シナリオIDは英数字、アンダースコア、ハイフンのみ使用可能です');
                        }
                        break;
                }
            }
            
            return input ? input.trim() : '';
        }

        function sanitizeHTML(str) {
            if (!str) return '';
            const div = document.createElement('div');
            div.textContent = str;
            return div.innerHTML;
        }

        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substr(2);
        }

        async function waitForSupabase(timeout = 10000) {
            const startTime = Date.now();
            
            while (!window.supabase) {
                if (Date.now() - startTime > timeout) {
                    throw new Error('Supabaseライブラリの読み込みがタイムアウトしました');
                }
                await new Promise(resolve => setTimeout(resolve, 100));
            }
            
            console.log('Supabaseライブラリ読み込み完了');
        }

        async function safeSupabaseOperation(operation, operationName, maxRetries = 3) {
            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const result = await operation();
                    
                    if (result.error) {
                        throw new Error(`Supabaseエラー: ${result.error.message}`);
                    }
                    
                    return {
                        success: true,
                        data: result.data,
                        count: result.count
                    };
                    
                } catch (error) {
                    console.warn(`${operationName} 試行 ${attempt}/${maxRetries} 失敗:`, error);
                    
                    if (attempt === maxRetries) {
                        console.error(`${operationName} 最終失敗:`, error);
                        return {
                            success: false,
                            error: error.message,
                            data: null
                        };
                    }
                    
                    await new Promise(resolve => setTimeout(resolve, 1000 * attempt));
                }
            }
        }

        // エラー・成功表示システム
        function showErrorInUI(message, error = null) {
            try {
                const errorBar = safeGetElement('error-bar');
                const errorMessage = safeGetElement('error-message');
                
                if (!errorBar || !errorMessage) return;
                
                let displayMessage = message;
                if (error) {
                    displayMessage += ` (詳細: ${error.message || error})`;
                }
                
                errorMessage.textContent = displayMessage;
                errorBar.classList.add('show');
                
                console.error('UIエラー表示:', displayMessage);
                
                setTimeout(() => {
                    hideError();
                }, 10000);
                
            } catch (err) {
                console.error('エラー表示システムエラー:', err);
            }
        }

        function hideError() {
            try {
                const errorBar = safeGetElement('error-bar');
                if (errorBar) {
                    errorBar.classList.remove('show');
                }
            } catch (error) {
                console.error('エラー非表示エラー:', error);
            }
        }

        function showSuccessInUI(message) {
            try {
                const successBar = safeGetElement('success-bar');
                const successMessage = safeGetElement('success-message');
                
                if (!successBar || !successMessage) return;
                
                successMessage.textContent = message;
                successBar.classList.add('show');
                
                const autoSaveIndicator = safeGetElement('auto-save-indicator');
                if (autoSaveIndicator && message.includes('保存')) {
                    autoSaveIndicator.classList.add('show');
                    setTimeout(() => {
                        autoSaveIndicator.classList.remove('show');
                    }, 2000);
                }
                
                setTimeout(() => {
                    successBar.classList.remove('show');
                }, 3000);
                
            } catch (error) {
                console.error('成功表示エラー:', error);
            }
        }

        function showLoading(show = true) {
            try {
                const loadingOverlay = safeGetElement('loading-overlay');
                if (loadingOverlay) {
                    if (show) {
                        loadingOverlay.classList.add('show');
                    } else {
                        loadingOverlay.classList.remove('show');
                    }
                }
            } catch (error) {
                console.error('ローディング表示エラー:', error);
            }
        }

        // データ管理システム
        class DataManager {
            constructor(supabase) {
                this.supabase = supabase;
                this.currentCurrency = 'USDJPY';
                this.currentScenario = 'scenario1';
                this.saveQueue = new Map();
                this.saveTimer = null;
                this.saveDelay = 2000;
                this.lastSaveTime = 0;
                this.isOnline = navigator.onLine;
                this.offlineQueue = [];
                this.init();
            }

            init() {
                window.addEventListener('online', () => {
                    this.isOnline = true;
                    this.syncOfflineData();
                });

                window.addEventListener('offline', () => {
                    this.isOnline = false;
                });

                console.log('DataManager初期化完了');
            }

            generateKey(currency, scenario, field) {
                return `${currency}_${scenario}_${field}`;
            }

            async autoSave(currency, scenario, field, value) {
                try {
                    validateInput(currency, 'currency', true);
                    validateInput(scenario, 'scenario', true);
                    
                    if (!field) {
                        throw new Error('フィールド名が必要です');
                    }

                    const key = this.generateKey(currency, scenario, field);
                    
                    this.saveQueue.set(key, {
                        currency,
                        scenario,
                        field,
                        value,
                        timestamp: Date.now()
                    });

                    if (this.saveTimer) {
                        clearTimeout(this.saveTimer);
                    }

                    this.saveTimer = setTimeout(() => {
                        this.processSaveQueue();
                    }, this.saveDelay);

                    console.log(`自動保存キューに追加: ${key}`);

                } catch (error) {
                    console.error('自動保存エラー:', error);
                    showErrorInUI('自動保存に失敗しました', error);
                }
            }

            async processSaveQueue() {
                if (this.saveQueue.size === 0) return;

                const now = Date.now();
                if (now - this.lastSaveTime < 1000) {
                    setTimeout(() => this.processSaveQueue(), 1000);
                    return;
                }

                const queueItems = Array.from(this.saveQueue.values());
                this.saveQueue.clear();

                if (!this.isOnline) {
                    this.offlineQueue.push(...queueItems);
                    console.log('オフライン: 保存をキューに追加');
                    return;
                }

                try {
                    showLoading(true);
                    
                    const savePromises = queueItems.map(item => this.saveToDatabase(item));
                    const results = await Promise.allSettled(savePromises);
                    
                    let successCount = 0;
                    let errorCount = 0;
                    
                    results.forEach((result, index) => {
                        if (result.status === 'fulfilled' && result.value.success) {
                            successCount++;
                        } else {
                            errorCount++;
                            console.error(`保存失敗 ${queueItems[index].currency}-${queueItems[index].scenario}-${queueItems[index].field}:`, result.reason);
                        }
                    });

                    this.lastSaveTime = now;

                    if (successCount > 0) {
                        showSuccessInUI(`${successCount}件のデータを保存しました`);
                    }
                    
                    if (errorCount > 0) {
                        showErrorInUI(`${errorCount}件の保存に失敗しました`);
                    }

                } catch (error) {
                    console.error('保存キュー処理エラー:', error);
                    showErrorInUI('データ保存に失敗しました', error);
                } finally {
                    showLoading(false);
                }
            }

            async saveToDatabase(item) {
                try {
                    const { currency, scenario, field, value, timestamp } = item;
                    const id = this.generateKey(currency, scenario, field);

                    const dataToSave = {
                        id,
                        currency,
                        scenario,
                        field,
                        data: {
                            value,
                            timestamp,
                            version: 1
                        },
                        updated_at: new Date().toISOString()
                    };

                    const result = await safeSupabaseOperation(
                        () => this.supabase
                            .from('fx_analysis_data')
                            .upsert(dataToSave, { onConflict: 'id' }),
                        `データ保存: ${id}`,
                        2
                    );

                    if (result.success) {
                        console.log(`データ保存成功: ${id}`);
                        return result;
                    } else {
                        throw new Error(result.error);
                    }

                } catch (error) {
                    console.error('データベース保存エラー:', error);
                    throw error;
                }
            }

            async loadData(currency, scenario, field) {
                try {
                    validateInput(currency, 'currency', true);
                    validateInput(scenario, 'scenario', true);
                    
                    if (!field) {
                        throw new Error('フィールド名が必要です');
                    }

                    const id = this.generateKey(currency, scenario, field);

                    const result = await safeSupabaseOperation(
                        () => this.supabase
                            .from('fx_analysis_data')
                            .select('data')
                            .eq('id', id)
                            .single(),
                        `データ読み込み: ${id}`,
                        2
                    );

                    if (result.success && result.data) {
                        const value = result.data.data?.value;
                        console.log(`データ読み込み成功: ${id} = ${value}`);
                        return value;
                    } else {
                        console.log(`データが見つかりません: ${id}`);
                        return null;
                    }

                } catch (error) {
                    console.error('データ読み込みエラー:', error);
                    return null;
                }
            }

            async forceSaveAll() {
                try {
                    if (this.saveTimer) {
                        clearTimeout(this.saveTimer);
                    }
                    await this.processSaveQueue();
                    console.log('強制保存完了');
                } catch (error) {
                    console.error('強制保存エラー:', error);
                    throw error;
                }
            }

            async syncOfflineData() {
                if (this.offlineQueue.length === 0) return;

                try {
                    console.log(`オフラインデータ同期開始: ${this.offlineQueue.length}件`);
                    
                    const syncPromises = this.offlineQueue.map(item => this.saveToDatabase(item));
                    const results = await Promise.allSettled(syncPromises);
                    
                    let successCount = 0;
                    results.forEach(result => {
                        if (result.status === 'fulfilled' && result.value.success) {
                            successCount++;
                        }
                    });

                    this.offlineQueue = [];
                    
                    if (successCount > 0) {
                        showSuccessInUI(`オフライン中の${successCount}件のデータを同期しました`);
                    }

                } catch (error) {
                    console.error('オフラインデータ同期エラー:', error);
                    showErrorInUI('オフラインデータの同期に失敗しました', error);
                }
            }

            async deleteData(currency, scenario, field) {
                try {
                    const id = this.generateKey(currency, scenario, field);

                    const result = await safeSupabaseOperation(
                        () => this.supabase
                            .from('fx_analysis_data')
                            .delete()
                            .eq('id', id),
                        `データ削除: ${id}`,
                        2
                    );

                    if (result.success) {
                        console.log(`データ削除成功: ${id}`);
                        return true;
                    } else {
                        throw new Error(result.error);
                    }

                } catch (error) {
                    console.error('データ削除エラー:', error);
                    return false;
                }
            }

            async getAllData(currency) {
                try {
                    validateInput(currency, 'currency', true);

                    const result = await safeSupabaseOperation(
                        () => this.supabase
                            .from('fx_analysis_data')
                            .select('*')
                            .eq('currency', currency)
                            .order('updated_at', { ascending: false }),
                        `全データ取得: ${currency}`,
                        2
                    );

                    if (result.success) {
                        return result.data || [];
                    } else {
                        throw new Error(result.error);
                    }

                } catch (error) {
                    console.error('全データ取得エラー:', error);
                    return [];
                }
            }
        }

        // シナリオ管理システム
        class ScenarioManager {
            constructor(dataManager) {
                this.dataManager = dataManager;
                this.draggedElement = null;
                this.init();
            }

            init() {
                this.setupDragAndDrop();
                this.setupScenarioButtons();
                console.log('ScenarioManager初期化完了');
            }

            setupScenarioButtons() {
                document.querySelectorAll('.scenario-btn').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        e.preventDefault();
                        const scenarioId = btn.dataset.scenario;
                        if (scenarioId && app) {
                            await app.selectScenario(scenarioId);
                        }
                    });
                });
            }

            setupDragAndDrop() {
                const scenarioButtons = document.getElementById('scenario-buttons');
                if (!scenarioButtons) return;

                scenarioButtons.addEventListener('dragstart', (e) => {
                    if (e.target.closest('.scenario-item')) {
                        this.draggedElement = e.target.closest('.scenario-item');
                        this.draggedElement.classList.add('dragging');
                        e.dataTransfer.effectAllowed = 'move';
                    }
                });

                scenarioButtons.addEventListener('dragend', (e) => {
                    if (this.draggedElement) {
                        this.draggedElement.classList.remove('dragging');
                        document.querySelectorAll('.scenario-item').forEach(item => {
                            item.classList.remove('drag-over');
                        });
                        this.draggedElement = null;
                    }
                });

                scenarioButtons.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const afterElement = this.getDragAfterElement(scenarioButtons, e.clientX);
                    const draggedItem = this.draggedElement;
                    
                    if (afterElement == null) {
                        scenarioButtons.appendChild(draggedItem);
                    } else {
                        scenarioButtons.insertBefore(draggedItem, afterElement);
                    }
                });

                scenarioButtons.addEventListener('dragenter', (e) => {
                    e.preventDefault();
                    const item = e.target.closest('.scenario-item');
                    if (item && item !== this.draggedElement) {
                        item.classList.add('drag-over');
                    }
                });

                scenarioButtons.addEventListener('dragleave', (e) => {
                    const item = e.target.closest('.scenario-item');
                    if (item) {
                        item.classList.remove('drag-over');
                    }
                });
            }

            getDragAfterElement(container, x) {
                const draggableElements = [...container.querySelectorAll('.scenario-item:not(.dragging)')];
                
                return draggableElements.reduce((closest, child) => {
                    const box = child.getBoundingClientRect();
                    const offset = x - box.left - box.width / 2;
                    
                    if (offset < 0 && offset > closest.offset) {
                        return { offset: offset, element: child };
                    } else {
                        return closest;
                    }
                }, { offset: Number.NEGATIVE_INFINITY }).element;
            }

            async addScenario(currency) {
                try {
                    validateInput(currency, 'currency', true);

                    const scenarioName = prompt('新しいシナリオ名を入力してください:');
                    if (!scenarioName) return;

                    const sanitizedName = scenarioName.trim();
                    if (!sanitizedName) {
                        showErrorInUI('シナリオ名を入力してください');
                        return;
                    }

                    const scenarioId = `scenario_${Date.now()}`;
                    
                    const scenarioButtons = document.getElementById('scenario-buttons');
                    if (!scenarioButtons) {
                        showErrorInUI('シナリオボタンコンテナが見つかりません');
                        return;
                    }

                    const scenarioItem = document.createElement('div');
                    scenarioItem.className = 'scenario-item slide-in';
                    scenarioItem.draggable = true;

                    scenarioItem.innerHTML = `
                        <button class="scenario-btn" data-scenario="${scenarioId}">
                            <span class="drag-handle">⋮⋮</span>
                            ${sanitizeHTML(sanitizedName)}
                        </button>
                        <div class="status-indicator">📊 未設定</div>
                    `;

                    scenarioButtons.appendChild(scenarioItem);

                    const newBtn = scenarioItem.querySelector('.scenario-btn');
                    newBtn.addEventListener('click', async (e) => {
                        e.preventDefault();
                        if (app) {
                            await app.selectScenario(scenarioId);
                        }
                    });

                    await this.dataManager.autoSave(currency, scenarioId, 'name', sanitizedName);
                    await this.dataManager.autoSave(currency, scenarioId, 'created', new Date().toISOString());

                    showSuccessInUI(`シナリオ「${sanitizedName}」を追加しました`);
                    console.log(`シナリオ追加: ${scenarioId} - ${sanitizedName}`);

                } catch (error) {
                    console.error('シナリオ追加エラー:', error);
                    showErrorInUI('シナリオの追加に失敗しました', error);
                }
            }

            async deleteScenario(currency, scenarioId) {
                try {
                    validateInput(currency, 'currency', true);
                    validateInput(scenarioId, 'scenario', true);

                    const scenarioBtn = document.querySelector(`[data-scenario="${scenarioId}"]`);
                    if (!scenarioBtn) {
                        showErrorInUI('削除対象のシナリオが見つかりません');
                        return;
                    }

                    const scenarioName = scenarioBtn.textContent.replace('⋮⋮', '').trim();
                    
                    if (!confirm(`シナリオ「${scenarioName}」を削除しますか？\n関連するすべてのデータが削除されます。\nこの操作は取り消せません。`)) {
                        return;
                    }

                    const scenarioButtons = document.querySelectorAll('.scenario-btn');
                    if (scenarioButtons.length <= 1) {
                        showErrorInUI('最後のシナリオは削除できません');
                        return;
                    }

                    const scenarioItem = scenarioBtn.closest('.scenario-item');
                    if (scenarioItem) {
                        scenarioItem.remove();
                    }

                    const fields = ['name', 'memo', 'analysisStatus', 'targetWave', 'images', 'created'];
                    const deletePromises = fields.map(field => 
                        this.dataManager.deleteData(currency, scenarioId, field)
                    );
                    
                    await Promise.all(deletePromises);

                    if (this.dataManager.currentScenario === scenarioId) {
                        const firstBtn = document.querySelector('.scenario-btn');
                        if (firstBtn && app) {
                            await app.selectScenario(firstBtn.dataset.scenario);
                        }
                    }

                    showSuccessInUI(`シナリオ「${scenarioName}」を削除しました`);
                    console.log(`シナリオ削除: ${scenarioId}`);

                } catch (error) {
                    console.error('シナリオ削除エラー:', error);
                    showErrorInUI('シナリオの削除に失敗しました', error);
                }
            }

            async updateScenarioUI(currency) {
                try {
                    const scenarioButtons = document.querySelectorAll('.scenario-btn');
                    
                    for (const btn of scenarioButtons) {
                        const scenarioId = btn.dataset.scenario;
                        if (!scenarioId) continue;

                        const [name, status] = await Promise.all([
                            this.dataManager.loadData(currency, scenarioId, 'name'),
                            this.dataManager.loadData(currency, scenarioId, 'analysisStatus')
                        ]);

                        if (name) {
                            const dragHandle = btn.querySelector('.drag-handle');
                            const handleText = dragHandle ? dragHandle.outerHTML : '<span class="drag-handle">⋮⋮</span>';
                            btn.innerHTML = handleText + sanitizeHTML(name);
                        }

                        const statusIndicator = btn.parentNode?.querySelector('.status-indicator');
                        if (statusIndicator) {
                            if (status) {
                                const statusEmoji = {
                                    '検討中': '🤔',
                                    '計算中': '🔄',
                                    '実戦': '⚡',
                                    '利確': '📈',
                                    '損切り': '📉',
                                    '見送り': '👀'
                                };
                                statusIndicator.textContent = `${statusEmoji[status] || '📊'} ${status}`;
                                statusIndicator.className = `status-indicator status-${status}`;
                            } else {
                                statusIndicator.textContent = '📊 未設定';
                                statusIndicator.className = 'status-indicator';
                            }
                        }
                    }

                    console.log(`シナリオUI更新完了: ${currency}`);

                } catch (error) {
                    console.error('シナリオUI更新エラー:', error);
                }
            }

            async displayScenarioImages(currency, scenarioId) {
                try {
                    const images = await this.dataManager.loadData(currency, scenarioId, 'images');
                    
                    [1, 2].forEach(areaNum => {
                        const imageArea = safeGetElement(`image-area-${areaNum}`);
                        if (!imageArea) return;

                        const dropZone = imageArea.querySelector('.drop-zone');
                        if (!dropZone) return;

                        if (images && images[areaNum - 1]) {
                            const imageData = images[areaNum - 1];
                            this.displayImageInArea(dropZone, imageData.url, imageData.name);
                        } else {
                            this.resetImageArea(dropZone, areaNum);
                        }
                    });

                    console.log(`画像表示更新: ${currency} - ${scenarioId}`);

                } catch (error) {
                    console.error('画像表示エラー:', error);
                }
            }

            displayImageInArea(dropZone, imageUrl, imageName) {
                try {
                    dropZone.innerHTML = `
                        <img src="${imageUrl}" alt="${imageName}" class="image-preview">
                        <div class="image-controls">
                            <button class="btn btn-sm btn-danger" onclick="this.closest('.drop-zone').parentNode.querySelector('input').click()">
                                🔄 変更
                            </button>
                            <button class="btn btn-sm btn-danger" onclick="removeImage(this)">
                                🗑️ 削除
                            </button>
                        </div>
                        <p style="font-size: 0.8rem; color: var(--secondary-color); margin-top: 5px;">
                            ${sanitizeHTML(imageName)}
                        </p>
                    `;
                } catch (error) {
                    console.error('画像エリア表示エラー:', error);
                }
            }

            resetImageArea(dropZone, areaNum) {
                try {
                    dropZone.innerHTML = `
                        <p>📷 画像をドラッグ&ドロップ<br>または<br>クリックして選択</p>
                        <input type="file" class="file-input" id="file-input-${areaNum}" accept="image/*" multiple>
                        <div class="image-upload-progress" style="display: none;">
                            <div class="image-upload-progress-bar"></div>
                        </div>
                    `;

                    this.setupImageUpload(areaNum);
                } catch (error) {
                    console.error('画像エリアリセットエラー:', error);
                }
            }

            setupImageUpload(areaNum) {
                try {
                    const dropZone = document.querySelector(`#image-area-${areaNum} .drop-zone`);
                    const fileInput = safeGetElement(`file-input-${areaNum}`);
                    
                    if (!dropZone || !fileInput) return;

                    dropZone.addEventListener('click', () => {
                        fileInput.click();
                    });

                    fileInput.addEventListener('change', (e) => {
                        this.handleFileSelect(e.target.files, areaNum);
                    });

                    dropZone.addEventListener('dragover', (e) => {
                        e.preventDefault();
                        dropZone.classList.add('dragover');
                    });

                    dropZone.addEventListener('dragleave', () => {
                        dropZone.classList.remove('dragover');
                    });

                    dropZone.addEventListener('drop', (e) => {
                        e.preventDefault();
                        dropZone.classList.remove('dragover');
                        this.handleFileSelect(e.dataTransfer.files, areaNum);
                    });

                } catch (error) {
                    console.error('画像アップロード設定エラー:', error);
                }
            }

            async handleFileSelect(files, areaNum) {
                try {
                    if (!files || files.length === 0) return;

                    const file = files[0];
                    
                    if (!file.type.startsWith('image/')) {
                        showErrorInUI('画像ファイルを選択してください');
                        return;
                    }

                    if (file.size > 10 * 1024 * 1024) {
                        showErrorInUI('ファイルサイズは10MB以下にしてください');
                        return;
                    }

                    const progressBar = document.querySelector(`#image-area-${areaNum} .image-upload-progress`);
                    const progressBarFill = document.querySelector(`#image-area-${areaNum} .image-upload-progress-bar`);
                    
                    if (progressBar) {
                        progressBar.style.display = 'block';
                        progressBarFill.style.width = '0%';
                    }

                    showLoading(true);

                    const fileName = `${this.dataManager.currentCurrency}_${this.dataManager.currentScenario}_area${areaNum}_${Date.now()}.${file.name.split('.').pop()}`;

                    const uploadResult = await this.uploadImageToSupabase(file, fileName, (progress) => {
                        if (progressBarFill) {
                            progressBarFill.style.width = `${progress}%`;
                        }
                    });

                    if (uploadResult.success) {
                        const imageData = {
                            url: uploadResult.url,
                            name: file.name,
                            fileName: fileName,
                            uploadedAt: new Date().toISOString()
                        };

                        await this.saveImageData(areaNum, imageData);
                        
                        const dropZone = document.querySelector(`#image-area-${areaNum} .drop-zone`);
                        if (dropZone) {
                            this.displayImageInArea(dropZone, imageData.url, imageData.name);
                        }

                        showSuccessInUI('画像をアップロードしました');
                    } else {
                        throw new Error(uploadResult.error);
                    }

                } catch (error) {
                    console.error('ファイル選択処理エラー:', error);
                    showErrorInUI('画像のアップロードに失敗しました', error);
                } finally {
                    showLoading(false);
                    const progressBar = document.querySelector(`#image-area-${areaNum} .image-upload-progress`);
                    if (progressBar) {
                        progressBar.style.display = 'none';
                    }
                }
            }

            async uploadImageToSupabase(file, fileName, onProgress) {
                try {
                    const result = await safeSupabaseOperation(
                        () => this.dataManager.supabase.storage
                            .from('fx-images')
                            .upload(fileName, file, {
                                cacheControl: '3600',
                                upsert: true
                            }),
                        `画像アップロード: ${fileName}`,
                        2
                    );

                    if (result.success) {
                        const urlResult = await safeSupabaseOperation(
                            () => this.dataManager.supabase.storage
                                .from('fx-images')
                                .getPublicUrl(fileName),
                            `画像URL取得: ${fileName}`,
                            2
                        );

                        if (urlResult.success && urlResult.data) {
                            onProgress(100);
                            return {
                                success: true,
                                url: urlResult.data.publicUrl,
                                fileName: fileName
                            };
                        } else {
                            throw new Error('画像URLの取得に失敗しました');
                        }
                    } else {
                        throw new Error(result.error);
                    }

                } catch (error) {
                    console.error('Supabase画像アップロードエラー:', error);
                    return {
                        success: false,
                        error: error.message
                    };
                }
            }

            async saveImageData(areaNum, imageData) {
                try {
                    const currentImages = await this.dataManager.loadData(
                        this.dataManager.currentCurrency,
                        this.dataManager.currentScenario,
                        'images'
                    ) || [];

                    currentImages[areaNum - 1] = imageData;

                    await this.dataManager.autoSave(
                        this.dataManager.currentCurrency,
                        this.dataManager.currentScenario,
                        'images',
                        currentImages
                    );

                    console.log(`画像データ保存: エリア${areaNum}`);

                } catch (error) {
                    console.error('画像データ保存エラー:', error);
                    throw error;
                }
            }

            async removeImage(areaNum) {
                try {
                    const currentImages = await this.dataManager.loadData(
                        this.dataManager.currentCurrency,
                        this.dataManager.currentScenario,
                        'images'
                    ) || [];

                    if (currentImages[areaNum - 1]) {
                        const imageData = currentImages[areaNum - 1];
                        
                        if (imageData.fileName) {
                            await safeSupabaseOperation(
                                () => this.dataManager.supabase.storage
                                    .from('fx-images')
                                    .remove([imageData.fileName]),
                                `画像削除: ${imageData.fileName}`,
                                2
                            );
                        }

                        currentImages[areaNum - 1] = null;

                        await this.dataManager.autoSave(
                            this.dataManager.currentCurrency,
                            this.dataManager.currentScenario,
                            'images',
                            currentImages
                        );

                        const dropZone = document.querySelector(`#image-area-${areaNum} .drop-zone`);
                        if (dropZone) {
                            this.resetImageArea(dropZone, areaNum);
                        }

                        showSuccessInUI('画像を削除しました');
                    }

                } catch (error) {
                    console.error('画像削除エラー:', error);
                    showErrorInUI('画像の削除に失敗しました', error);
                }
            }
        }

        // グローバル関数として画像削除を追加
        window.removeImage = function(button) {
            const imageArea = button.closest('.image-area');
            if (!imageArea) return;
            
            const areaNum = imageArea.id.includes('1') ? 1 : 2;
            
            if (app && app.scenarioManager) {
                app.scenarioManager.removeImage(areaNum);
            }
        };

        // 履歴管理システム
        class HistoryManager {
            constructor(supabase) {
                this.supabase = supabase;
                this.maxHistoryItems = 200;
                this.searchTimeout = null;
                this.currentSearchTerm = '';
                this.init();
            }

            init() {
                this.setupHistorySearch();
                console.log('HistoryManager初期化完了');
            }

            setupHistorySearch() {
                const searchInput = safeGetElement('history-search');
                if (searchInput) {
                    searchInput.addEventListener('input', (e) => {
                        clearTimeout(this.searchTimeout);
                        this.searchTimeout = setTimeout(() => {
                            this.searchHistory(e.target.value);
                        }, 300);
                    });
                }
            }

            async saveToHistory(currency, scenario, field, value, action = 'update') {
                try {
                    if (!value || (typeof value === 'string' && value.trim() === '')) {
                        return;
                    }

                    const historyItem = {
                        id: generateId(),
                        currency,
                        scenario,
                        field,
                        value: typeof value === 'object' ? JSON.stringify(value) : value,
                        action,
                        timestamp: new Date().toISOString(),
                        preview: this.generatePreview(value)
                    };

                    const result = await safeSupabaseOperation(
                        () => this.supabase
                            .from('fx_analysis_history')
                            .insert(historyItem),
                        '履歴保存',
                        2
                    );

                    if (result.success) {
                        console.log(`履歴保存成功: ${currency}-${scenario}-${field}`);
                        await this.cleanupOldHistory();
                    } else {
                        console.warn('履歴保存失敗:', result.error);
                    }

                } catch (error) {
                    console.error('履歴保存エラー:', error);
                }
            }

            generatePreview(value) {
                try {
                    if (!value) return '';
                    
                    let text = typeof value === 'object' ? JSON.stringify(value) : String(value);
                    
                    text = text.replace(/\s+/g, ' ').trim();
                    
                    return text.length > 100 ? text.substring(0, 100) + '...' : text;
                    
                } catch (error) {
                    console.error('プレビュー生成エラー:', error);
                    return 'プレビュー生成エラー';
                }
            }

            async searchHistory(searchTerm = '') {
                try {
                    this.currentSearchTerm = searchTerm;
                    
                    let query = this.supabase
                        .from('fx_analysis_history')
                        .select('*')
                        .order('timestamp', { ascending: false })
                        .limit(50);

                    if (searchTerm.trim()) {
                        query = query.or(`currency.ilike.%${searchTerm}%,scenario.ilike.%${searchTerm}%,field.ilike.%${searchTerm}%,preview.ilike.%${searchTerm}%`);
                    }

                    const result = await safeSupabaseOperation(
                        () => query,
                        '履歴検索',
                        2
                    );

                    if (result.success) {
                        await this.displayHistoryResults(result.data || []);
                    } else {
                        console.error('履歴検索エラー:', result.error);
                        this.displayHistoryResults([]);
                    }

                } catch (error) {
                    console.error('履歴検索エラー:', error);
                    this.displayHistoryResults([]);
                }
            }

            async displayHistoryResults(historyItems) {
                try {
                    const historyList = safeGetElement('history-list');
                    if (!historyList) return;

                    if (historyItems.length === 0) {
                        historyList.innerHTML = `
                            <div style="text-align: center; padding: 40px; color: var(--secondary-color);">
                                <p>📝 履歴が見つかりません</p>
                                ${this.currentSearchTerm ? '<p>検索条件を変更してお試しください</p>' : '<p>データを編集すると履歴が作成されます</p>'}
                            </div>
                        `;
                        return;
                    }

                    const historyHTML = historyItems.map(item => {
                        const date = new Date(item.timestamp);
                        const formattedDate = date.toLocaleDateString('ja-JP') + ' ' + date.toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' });
                        
                        const fieldDisplayName = {
                            'memo': 'メモ',
                            'analysisStatus': 'ステータス',
                            'targetWave': '狙う波',
                            'images': '画像',
                            'fixedPrompt': 'プロンプト'
                        }[item.field] || item.field;

                        return `
                            <div class="history-item" onclick="restoreHistoryItem('${item.id}')">
                                <div class="history-item-header">
                                    <div class="history-item-title">
                                        ${sanitizeHTML(item.currency)} - ${sanitizeHTML(item.scenario)} - ${fieldDisplayName}
                                    </div>
                                    <div class="history-item-date">${formattedDate}</div>
                                </div>
                                <div class="history-item-preview">
                                    ${sanitizeHTML(item.preview)}
                                </div>
                            </div>
                        `;
                    }).join('');

                    historyList.innerHTML = historyHTML;

                } catch (error) {
                    console.error('履歴表示エラー:', error);
                    const historyList = safeGetElement('history-list');
                    if (historyList) {
                        historyList.innerHTML = '<div style="text-align: center; padding: 20px; color: var(--danger-color);">履歴の表示でエラーが発生しました</div>';
                    }
                }
            }

            async restoreHistoryItem(historyId) {
                try {
                    const result = await safeSupabaseOperation(
                        () => this.supabase
                            .from('fx_analysis_history')
                            .select('*')
                            .eq('id', historyId)
                            .single(),
                        '履歴アイテム取得',
                        2
                    );

                    if (!result.success || !result.data) {
                        showErrorInUI('履歴アイテムが見つかりません');
                        return;
                    }

                    const historyItem = result.data;
                    
                    if (!confirm(`以下の履歴を復元しますか？\n\n通貨ペア: ${historyItem.currency}\nシナリオ: ${historyItem.scenario}\nフィールド: ${historyItem.field}\n\n現在のデータは上書きされます。`)) {
                        return;
                    }

                    let valueToRestore = historyItem.value;
                    
                    try {
                        valueToRestore = JSON.parse(historyItem.value);
                    } catch {
                        // JSON形式でない場合はそのまま使用
                    }

                    if (app && app.dataManager) {
                        await app.dataManager.autoSave(
                            historyItem.currency,
                            historyItem.scenario,
                            historyItem.field,
                            valueToRestore
                        );

                        await app.dataManager.forceSaveAll();

                        if (historyItem.currency === app.dataManager.currentCurrency && 
                            historyItem.scenario === app.dataManager.currentScenario) {
                            await app.updateCurrentDisplay();
                        }

                        showSuccessInUI('履歴を復元しました');
                        
                        if (app.closeHistoryPanel) {
                            app.closeHistoryPanel();
                        }
                    }

                } catch (error) {
                    console.error('履歴復元エラー:', error);
                    showErrorInUI('履歴の復元に失敗しました', error);
                }
            }

            async cleanupOldHistory() {
                try {
                    const countResult = await safeSupabaseOperation(
                        () => this.supabase
                            .from('fx_analysis_history')
                            .select('id', { count: 'exact', head: true }),
                        '履歴件数取得',
                        1
                    );

                    if (countResult.success && countResult.count > this.maxHistoryItems) {
                        const deleteCount = countResult.count - this.maxHistoryItems;
                        
                        const oldItemsResult = await safeSupabaseOperation(
                            () => this.supabase
                                .from('fx_analysis_history')
                                .select('id')
                                .order('timestamp', { ascending: true })
                                .limit(deleteCount),
                            '古い履歴取得',
                            1
                        );

                        if (oldItemsResult.success && oldItemsResult.data) {
                            const idsToDelete = oldItemsResult.data.map(item => item.id);
                            
                            await safeSupabaseOperation(
                                () => this.supabase
                                    .from('fx_analysis_history')
                                    .delete()
                                    .in('id', idsToDelete),
                                '古い履歴削除',
                                1
                            );

                            console.log(`古い履歴を${deleteCount}件削除しました`);
                        }
                    }

                } catch (error) {
                    console.error('履歴クリーンアップエラー:', error);
                }
            }

            async clearAllHistory() {
                try {
                    if (!confirm('すべての履歴を削除しますか？\nこの操作は取り消せません。')) {
                        return;
                    }

                    const result = await safeSupabaseOperation(
                        () => this.supabase
                            .from('fx_analysis_history')
                            .delete()
                            .neq('id', ''),
                        '全履歴削除',
                        2
                    );

                    if (result.success) {
                        showSuccessInUI('すべての履歴を削除しました');
                        await this.searchHistory('');
                    } else {
                        throw new Error(result.error);
                    }

                } catch (error) {
                    console.error('全履歴削除エラー:', error);
                    showErrorInUI('履歴の削除に失敗しました', error);
                }
            }
        }

        // グローバル関数として履歴復元を追加
        window.restoreHistoryItem = function(historyId) {
            if (app && app.historyManager) {
                app.historyManager.restoreHistoryItem(historyId);
            }
        };

        // バックアップ機能
        class BackupManager {
            constructor(supabase) {
                this.supabase = supabase;
                this.maxBackups = 10;
                this.init();
            }

            init() {
                console.log('BackupManager初期化完了');
            }

            async createBackup() {
                try {
                    showLoading(true);
                    
                    const backupData = await this.collectAllData();
                    
                    if (!backupData || Object.keys(backupData).length === 0) {
                        showErrorInUI('バックアップするデータがありません');
                        return;
                    }

                    const backupItem = {
                        id: generateId(),
                        name: `バックアップ_${new Date().toLocaleDateString('ja-JP').replace(/\//g, '')}_${new Date().toLocaleTimeString('ja-JP', { hour: '2-digit', minute: '2-digit' }).replace(/:/g, '')}`,
                        data: backupData,
                        created_at: new Date().toISOString(),
                        size: JSON.stringify(backupData).length
                    };

                    const result = await safeSupabaseOperation(
                        () => this.supabase
                            .from('fx_backups')
                            .insert(backupItem),
                        'バックアップ作成',
                        2
                    );

                    if (result.success) {
                        await this.cleanupOldBackups();
                        showSuccessInUI(`バックアップ「${backupItem.name}」を作成しました`);
                        console.log('バックアップ作成成功:', backupItem.name);
                    } else {
                        throw new Error(result.error);
                    }

                } catch (error) {
                    console.error('バックアップ作成エラー:', error);
                    showErrorInUI('バックアップの作成に失敗しました', error);
                } finally {
                    showLoading(false);
                }
            }

            async collectAllData() {
                try {
                    const [analysisData, historyData] = await Promise.all([
                        safeSupabaseOperation(
                            () => this.supabase
                                .from('fx_analysis_data')
                                .select('*')
                                .order('updated_at', { ascending: false }),
                            '分析データ取得',
                            2
                        ),
                        safeSupabaseOperation(
                            () => this.supabase
                                .from('fx_analysis_history')
                                .select('*')
                                .order('timestamp', { ascending: false })
                                .limit(100),
                            '履歴データ取得',
                            2
                        )
                    ]);

                    const backupData = {
                        version: '1.0',
                        timestamp: new Date().toISOString(),
                        analysisData: analysisData.success ? analysisData.data : [],
                        historyData: historyData.success ? historyData.data : [],
                        metadata: {
                            totalAnalysisItems: analysisData.success ? analysisData.data?.length || 0 : 0,
                            totalHistoryItems: historyData.success ? historyData.data?.length || 0 : 0,
                            currencies: this.extractCurrencies(analysisData.success ? analysisData.data : [])
                        }
                    };

                    console.log('バックアップデータ収集完了:', {
                        analysisItems: backupData.metadata.totalAnalysisItems,
                        historyItems: backupData.metadata.totalHistoryItems,
                        currencies: backupData.metadata.currencies
                    });

                    return backupData;

                } catch (error) {
                    console.error('データ収集エラー:', error);
                    throw error;
                }
            }

            extractCurrencies(analysisData) {
                try {
                    const currencies = new Set();
                    analysisData.forEach(item => {
                        if (item.currency) {
                            currencies.add(item.currency);
                        }
                    });
                    return Array.from(currencies);
                } catch (error) {
                    console.error('通貨抽出エラー:', error);
                    return [];
                }
            }

            async cleanupOldBackups() {
                try {
                    const result = await safeSupabaseOperation(
                        () => this.supabase
                            .from('fx_backups')
                            .select('id, created_at')
                            .order('created_at', { ascending: false }),
                        'バックアップ一覧取得',
                        1
                    );

                    if (result.success && result.data && result.data.length > this.maxBackups) {
                        const backupsToDelete = result.data.slice(this.maxBackups);
                        const idsToDelete = backupsToDelete.map(backup => backup.id);

                        await safeSupabaseOperation(
                            () => this.supabase
                                .from('fx_backups')
                                .delete()
                                .in('id', idsToDelete),
                            '古いバックアップ削除',
                            1
                        );

                        console.log(`古いバックアップを${backupsToDelete.length}件削除しました`);
                    }

                } catch (error) {
                    console.error('バックアップクリーンアップエラー:', error);
                }
            }

            async listBackups() {
                try {
                    const result = await safeSupabaseOperation(
                        () => this.supabase
                            .from('fx_backups')
                            .select('id, name, created_at, size')
                            .order('created_at', { ascending: false }),
                        'バックアップ一覧取得',
                        2
                    );

                    if (result.success) {
                        return result.data || [];
                    } else {
                        throw new Error(result.error);
                    }

                } catch (error) {
                    console.error('バックアップ一覧取得エラー:', error);
                    return [];
                }
            }

            async restoreBackup(backupId) {
                try {
                    if (!confirm('バックアップを復元しますか？\n現在のすべてのデータが置き換えられます。\nこの操作は取り消せません。')) {
                        return;
                    }

                    showLoading(true);

                    const result = await safeSupabaseOperation(
                        () => this.supabase
                            .from('fx_backups')
                            .select('*')
                            .eq('id', backupId)
                            .single(),
                        'バックアップデータ取得',
                        2
                    );

                    if (!result.success || !result.data) {
                        throw new Error('バックアップデータが見つかりません');
                    }

                    const backupData = result.data.data;
                    
                    if (!backupData || !backupData.analysisData) {
                        throw new Error('バックアップデータが無効です');
                    }

                    await this.clearCurrentData();

                    if (backupData.analysisData.length > 0) {
                        const analysisResult = await safeSupabaseOperation(
                            () => this.supabase
                                .from('fx_analysis_data')
                                .insert(backupData.analysisData),
                            '分析データ復元',
                            2
                        );

                        if (!analysisResult.success) {
                            throw new Error('分析データの復元に失敗しました');
                        }
                    }

                    if (backupData.historyData && backupData.historyData.length > 0) {
                        const historyResult = await safeSupabaseOperation(
                            () => this.supabase
                                .from('fx_analysis_history')
                                .insert(backupData.historyData),
                            '履歴データ復元',
                            2
                        );

                        if (!historyResult.success) {
                            console.warn('履歴データの復元に失敗しました:', historyResult.error);
                        }
                    }

                    showSuccessInUI('バックアップを復元しました。ページを再読み込みしています...');
                    
                    setTimeout(() => {
                        location.reload();
                    }, 2000);

                } catch (error) {
                    console.error('バックアップ復元エラー:', error);
                    showErrorInUI('バックアップの復元に失敗しました', error);
                } finally {
                    showLoading(false);
                }
            }

            async clearCurrentData() {
                try {
                    await Promise.all([
                        safeSupabaseOperation(
                            () => this.supabase
                                .from('fx_analysis_data')
                                .delete()
                                .neq('id', ''),
                            '現在の分析データ削除',
                            2
                        ),
                        safeSupabaseOperation(
                            () => this.supabase
                                .from('fx_analysis_history')
                                .delete()
                                .neq('id', ''),
                            '現在の履歴データ削除',
                            2
                        )
                    ]);

                    console.log('現在のデータ削除完了');

                } catch (error) {
                    console.error('現在のデータ削除エラー:', error);
                    throw error;
                }
            }

            async downloadBackup(backupId) {
                try {
                    const result = await safeSupabaseOperation(
                        () => this.supabase
                            .from('fx_backups')
                            .select('*')
                            .eq('id', backupId)
                            .single(),
                        'バックアップダウンロード',
                        2
                    );

                    if (!result.success || !result.data) {
                        throw new Error('バックアップデータが見つかりません');
                    }

                    const backupData = result.data;
                    const jsonData = JSON.stringify(backupData, null, 2);
                    const blob = new Blob([jsonData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);

                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `${backupData.name}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);

                    showSuccessInUI('バックアップをダウンロードしました');

                } catch (error) {
                    console.error('バックアップダウンロードエラー:', error);
                    showErrorInUI('バックアップのダウンロードに失敗しました', error);
                }
            }
        }

        // ダークモード管理
        class ThemeManager {
            constructor(dataManager) {
                this.dataManager = dataManager;
                this.currentTheme = 'light';
                this.init();
            }

            async init() {
                try {
                    const savedTheme = await this.dataManager.loadData('global', 'settings', 'theme');
                    
                    if (savedTheme) {
                        this.currentTheme = savedTheme;
                    } else {
                        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                        this.currentTheme = prefersDark ? 'dark' : 'light';
                    }

                    this.applyTheme(this.currentTheme);

                    window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
                        if (!await this.dataManager.loadData('global', 'settings', 'theme')) {
                            this.currentTheme = e.matches ? 'dark' : 'light';
                            this.applyTheme(this.currentTheme);
                        }
                    });

                    console.log('ThemeManager初期化完了:', this.currentTheme);

                } catch (error) {
                    console.error('テーマ初期化エラー:', error);
                    this.applyTheme('light');
                }
            }

            applyTheme(theme) {
                try {
                    document.documentElement.setAttribute('data-theme', theme);
                    
                    const themeToggle = safeGetElement('theme-toggle');
                    if (themeToggle) {
                        themeToggle.setAttribute('aria-label', 
                            theme === 'dark' ? 'ライトモードに切り替え' : 'ダークモードに切り替え'
                        );
                    }

                    const connectionStatus = safeGetElement('connection-status');
                    if (connectionStatus) {
                        connectionStatus.style.background = theme === 'dark' ? 
                            'rgba(40, 167, 69, 0.9)' : 'var(--success-color)';
                    }

                    console.log(`テーマ適用: ${theme}`);

                } catch (error) {
                    console.error('テーマ適用エラー:', error);
                }
            }

            async toggleTheme() {
                try {
                    this.currentTheme = this.currentTheme === 'light' ? 'dark' : 'light';
                    this.applyTheme(this.currentTheme);

                    await this.dataManager.autoSave('global', 'settings', 'theme', this.currentTheme);

                    showSuccessInUI(`${this.currentTheme === 'dark' ? 'ダーク' : 'ライト'}モードに切り替えました`);

                } catch (error) {
                    console.error('テーマ切り替えエラー:', error);
                    showErrorInUI('テーマの切り替えに失敗しました', error);
                }
            }

            getCurrentTheme() {
                return this.currentTheme;
            }
        }

        // 使用量監視
        class UsageMonitor {
            constructor(supabase) {
                this.supabase = supabase;
                this.dbLimit = 500;
                this.storageLimit = 1024;
                this.updateInterval = 30000;
                this.isUpdating = false;
                this.lastUpdate = 0;
                this.init();
            }

            init() {
                try {
                    this.updateUsage();
                    this.startPeriodicUpdate();

                    document.addEventListener('visibilitychange', () => {
                        if (!document.hidden) {
                            this.updateUsage();
                        }
                    });

                    console.log('使用量監視初期化完了');

                } catch (error) {
                    console.error('使用量監視初期化エラー:', error);
                }
            }

            startPeriodicUpdate() {
                setInterval(() => {
                    if (!this.isUpdating && !document.hidden) {
                        this.updateUsage();
                    }
                }, this.updateInterval);
            }

            async updateUsage() {
                if (this.isUpdating) return;

                const now = Date.now();
                if (now - this.lastUpdate < 5000) return;

                this.isUpdating = true;
                this.lastUpdate = now;

                try {
                    console.log('使用量更新開始');

                    const [dbUsage, storageUsage] = await Promise.all([
                        this.calculateDatabaseUsage(),
                        this.calculateStorageUsage()
                    ]);

                    this.updateProgressBar('db-usage', 'db-percent', dbUsage, this.dbLimit, 'データベース');
                    this.updateProgressBar('storage-usage', 'storage-percent', storageUsage, this.storageLimit, 'ストレージ');

                    this.checkUsageWarnings(dbUsage, storageUsage);

                    console.log(`使用量更新完了: DB=${dbUsage.toFixed(1)}MB, Storage=${storageUsage.toFixed(1)}MB`);

                } catch (error) {
                    console.error('使用量更新エラー:', error);

                    this.updateProgressBar('db-usage', 'db-percent', 0, this.dbLimit, 'データベース');
                    this.updateProgressBar('storage-usage', 'storage-percent', 0, this.storageLimit, 'ストレージ');

                } finally {
                    this.isUpdating = false;
                }
            }

            async calculateDatabaseUsage() {
                try {
                    const result = await safeSupabaseOperation(
                        () => this.supabase.from('fx_analysis_data').select('*'),
                        'データベース使用量計算',
                        1
                    );

                    if (!result.success || !result.data) {
                        return 0;
                    }

                    const dataSize = this.calculateDataSize(result.data);

                    const historyResult = await safeSupabaseOperation(
                        () => this.supabase.from('fx_analysis_history').select('*').limit(100),
                        '履歴データサイズ計算',
                        1
                    );

                    if (historyResult.success && historyResult.data) {
                        const historySize = this.calculateDataSize(historyResult.data);
                        return dataSize + historySize;
                    }

                    return dataSize;

                } catch (error) {
                    console.error('データベース使用量計算エラー:', error);
                    return 0;
                }
            }

            async calculateStorageUsage() {
                try {
                    const result = await safeSupabaseOperation(
                        () => this.supabase.storage.from('fx-images').list(),
                        'ストレージファイル一覧取得',
                        1
                    );

                    if (!result.success || !result.data) {
                        return 0;
                    }

                    let totalSize = 0;
                    for (const file of result.data) {
                        if (file.metadata && file.metadata.size) {
                            totalSize += file.metadata.size;
                        } else {
                            totalSize += 1024 * 1024;
                        }
                    }

                    return totalSize / (1024 * 1024);

                } catch (error) {
                    console.error('ストレージ使用量計算エラー:', error);
                    return this.estimateStorageUsageFromDatabase();
                }
            }

            async estimateStorageUsageFromDatabase() {
                try {
                    const result = await safeSupabaseOperation(
                        () => this.supabase.from('fx_analysis_data').select('data').like('id', '%_scenario_%_images'),
                        '画像データ推定',
                        1
                    );

                    if (!result.success || !result.data) {
                        return 0;
                    }

                    let imageCount = 0;
                    for (const item of result.data) {
                        const imagesData = item.data?.value;
                        if (imagesData && Array.isArray(imagesData)) {
                            imageCount += imagesData.filter(img => img).length;
                        }
                    }

                    return imageCount * 2;

                } catch (error) {
                    console.error('画像使用量推定エラー:', error);
                    return 0;
                }
            }

            calculateDataSize(data) {
                try {
                    if (!data || !Array.isArray(data)) return 0;

                    const jsonString = JSON.stringify(data);
                    const sizeInBytes = new Blob([jsonString]).size;

                    return sizeInBytes / (1024 * 1024);

                } catch (error) {
                    console.error('データサイズ計算エラー:', error);
                    return 0;
                }
            }

            updateProgressBar(progressId, percentId, usage, limit, label) {
                try {
                    const progressBar = safeGetElement(progressId);
                    const percentSpan = safeGetElement(percentId);

                    if (!progressBar || !percentSpan) {
                        console.warn(`プログレスバー要素が見つかりません: ${progressId}, ${percentId}`);
                        return;
                    }

                    const percentage = Math.min((usage / limit) * 100, 100);
                    const displayPercentage = Math.round(percentage * 10) / 10;

                    progressBar.value = percentage;
                    progressBar.max = 100;

                    percentSpan.textContent = `${displayPercentage}%`;

                    let color = '#007bff';
                    if (percentage > 90) {
                        color = '#dc3545';
                    } else if (percentage > 70) {
                        color = '#ffc107';
                    }

                    progressBar.style.accentColor = color;

                    const style = document.createElement('style');
                    style.textContent = `
                        #${progressId}::-webkit-progress-value {
                            background-color: ${color};
                            transition: background-color 0.3s ease;
                        }
                    `;

                    const existingStyle = document.querySelector(`style[data-progress="${progressId}"]`);
                    if (existingStyle) {
                        existingStyle.remove();
                    }

                    style.setAttribute('data-progress', progressId);
                    document.head.appendChild(style);

                    const tooltip = `${label}: ${usage.toFixed(1)}MB / ${limit}MB (${displayPercentage}%)`;
                    progressBar.title = tooltip;
                    percentSpan.title = tooltip;

                } catch (error) {
                    console.error('プログレスバー更新エラー:', error);
                }
            }

            checkUsageWarnings(dbUsage, storageUsage) {
                try {
                    const dbPercentage = (dbUsage / this.dbLimit) * 100;
                    const storagePercentage = (storageUsage / this.storageLimit) * 100;

                    const warningLevel = 80;
                    const criticalLevel = 90;

                    let warningMessage = '';

                    if (dbPercentage > criticalLevel) {
                        warningMessage += `データベース使用量が危険レベルです (${dbPercentage.toFixed(1)}%)。`;
                    } else if (dbPercentage > warningLevel) {
                        warningMessage += `データベース使用量が警告レベルです (${dbPercentage.toFixed(1)}%)。`;
                    }

                    if (storagePercentage > criticalLevel) {
                        warningMessage += `ストレージ使用量が危険レベルです (${storagePercentage.toFixed(1)}%)。`;
                    } else if (storagePercentage > warningLevel) {
                        warningMessage += `ストレージ使用量が警告レベルです (${storagePercentage.toFixed(1)}%)。`;
                    }

                    if (warningMessage) {
                        const lastWarning = localStorage.getItem('fx_last_usage_warning');
                        const now = Date.now();

                        if (!lastWarning || now - parseInt(lastWarning) > 60 * 60 * 1000) {
                            showErrorInUI(warningMessage + ' データの整理を検討してください。');
                            localStorage.setItem('fx_last_usage_warning', now.toString());
                        }
                    }

                } catch (error) {
                    console.error('使用量警告チェックエラー:', error);
                }
            }

            async forceUpdate() {
                this.lastUpdate = 0;
                await this.updateUsage();
                showSuccessInUI('使用量を更新しました');
            }

            async getUsageDetails() {
                try {
                    const [dbUsage, storageUsage] = await Promise.all([
                        this.calculateDatabaseUsage(),
                        this.calculateStorageUsage()
                    ]);

                    return {
                        database: {
                            usage: dbUsage,
                            limit: this.dbLimit,
                            percentage: (dbUsage / this.dbLimit) * 100
                        },
                        storage: {
                            usage: storageUsage,
                            limit: this.storageLimit,
                            percentage: (storageUsage / this.storageLimit) * 100
                        },
                        lastUpdate: new Date(this.lastUpdate).toISOString()
                    };

                } catch (error) {
                    console.error('使用量詳細取得エラー:', error);
                    return null;
                }
            }
        }

        // キーボードショートカット
        class KeyboardShortcuts {
            constructor(dataManager) {
                this.dataManager = dataManager;
                this.shortcuts = new Map();
                this.isEnabled = true;
                this.init();
            }

            init() {
                try {
                    this.defineShortcuts();
                    document.addEventListener('keydown', this.handleKeyDown.bind(this));
                    document.addEventListener('keyup', this.handleKeyUp.bind(this));
                    this.createHelpModal();

                    console.log('キーボードショートカット初期化完了');

                } catch (error) {
                    console.error('キーボードショートカット初期化エラー:', error);
                }
            }

            defineShortcuts() {
                this.shortcuts.set('ctrl+s', {
                    description: 'データを手動保存',
                    action: () => this.manualSave(),
                    preventDefault: true
                });

                this.shortcuts.set('ctrl+shift+s', {
                    description: 'バックアップ作成',
                    action: () => this.createBackup(),
                    preventDefault: true
                });

                this.shortcuts.set('ctrl+c', {
                    description: '選択要素をコピー',
                    action: () => this.copySelectedElement(),
                    preventDefault: true,
                    condition: () => this.isTextAreaFocused()
                });

                this.shortcuts.set('ctrl+v', {
                    description: '選択要素に貼り付け',
                    action: () => this.pasteToSelectedElement(),
                    preventDefault: true,
                    condition: () => this.isTextAreaFocused()
                });

                this.shortcuts.set('ctrl+left', {
                    description: '前のシナリオ',
                    action: () => this.previousScenario(),
                    preventDefault: true
                });

                this.shortcuts.set('ctrl+right', {
                    description: '次のシナリオ',
                    action: () => this.nextScenario(),
                    preventDefault: true
                });

                this.shortcuts.set('ctrl+home', {
                    description: 'トップに戻る',
                    action: () => this.goToTop(),
                    preventDefault: true
                });

                this.shortcuts.set('ctrl+d', {
                    description: 'ダークモード切り替え',
                    action: () => this.toggleDarkMode(),
                    preventDefault: true
                });

                this.shortcuts.set('ctrl+h', {
                    description: '履歴パネル切り替え',
                    action: () => this.toggleHistory(),
                    preventDefault: true
                });

                this.shortcuts.set('ctrl+n', {
                    description: '新しいシナリオ追加',
                    action: () => this.addNewScenario(),
                    preventDefault: true
                });

                this.shortcuts.set('f1', {
                    description: 'ショートカットヘルプ表示',
                    action: () => this.showHelp(),
                    preventDefault: true
                });

                this.shortcuts.set('escape', {
                    description: 'モーダル・パネルを閉じる',
                    action: () => this.closeModals(),
                    preventDefault: false
                });
            }

            handleKeyDown(event) {
                try {
                    if (!this.isEnabled) return;

                    const activeElement = document.activeElement;
                    const isInputElement = activeElement && (
                        activeElement.tagName === 'INPUT' ||
                        activeElement.tagName === 'TEXTAREA' ||
                        activeElement.contentEditable === 'true'
                    );

                    const keyCombo = this.generateKeyCombo(event);
                    const shortcut = this.shortcuts.get(keyCombo);

                    if (shortcut) {
                        if (shortcut.condition && !shortcut.condition()) {return;
                        }

                        if (isInputElement && !this.isAllowedInInput(keyCombo)) {
                            return;
                        }

                        if (shortcut.preventDefault) {
                            event.preventDefault();
                            event.stopPropagation();
                        }

                        shortcut.action();

                        console.log(`ショートカット実行: ${keyCombo}`);
                    }

                } catch (error) {
                    console.error('キーダウンハンドラエラー:', error);
                }
            }

            handleKeyUp(event) {
                // 必要に応じて実装
            }

            generateKeyCombo(event) {
                const keys = [];

                if (event.ctrlKey || event.metaKey) keys.push('ctrl');
                if (event.shiftKey) keys.push('shift');
                if (event.altKey) keys.push('alt');

                let keyName = event.key.toLowerCase();

                const keyMap = {
                    'arrowleft': 'left',
                    'arrowright': 'right',
                    'arrowup': 'up',
                    'arrowdown': 'down',
                    ' ': 'space'
                };

                keyName = keyMap[keyName] || keyName;
                keys.push(keyName);

                return keys.join('+');
            }

            isAllowedInInput(keyCombo) {
                const allowedInInput = [
                    'ctrl+s',
                    'ctrl+shift+s',
                    'ctrl+c',
                    'ctrl+v',
                    'ctrl+a',
                    'ctrl+z',
                    'ctrl+y',
                    'f1',
                    'escape'
                ];

                return allowedInInput.includes(keyCombo);
            }

            isTextAreaFocused() {
                const activeElement = document.activeElement;
                return activeElement && (
                    activeElement.tagName === 'TEXTAREA' ||
                    (activeElement.tagName === 'INPUT' && activeElement.type === 'text')
                );
            }

            async manualSave() {
                try {
                    if (!this.dataManager) {
                        showErrorInUI('データマネージャーが初期化されていません');
                        return;
                    }

                    const memo = safeGetElement('analysis-memo')?.value || '';
                    const prompt = safeGetElement('fixed-prompt')?.value || '';

                    await Promise.all([
                        this.dataManager.autoSave(
                            this.dataManager.currentCurrency,
                            this.dataManager.currentScenario,
                            'memo',
                            memo
                        ),
                        this.dataManager.autoSave('global', 'settings', 'fixedPrompt', prompt)
                    ]);

                    await this.dataManager.forceSaveAll();

                } catch (error) {
                    console.error('手動保存エラー:', error);
                    showErrorInUI('保存に失敗しました', error);
                }
            }

            async createBackup() {
                try {
                    if (app && app.backupManager) {
                        await app.backupManager.createBackup();
                    } else {
                        showErrorInUI('バックアップ機能が利用できません');
                    }
                } catch (error) {
                    console.error('バックアップ作成エラー:', error);
                }
            }

            async copySelectedElement() {
                try {
                    const activeElement = document.activeElement;

                    if (this.isTextAreaFocused()) {
                        if (activeElement.selectionStart !== activeElement.selectionEnd) {
                            const selectedText = activeElement.value.substring(
                                activeElement.selectionStart,
                                activeElement.selectionEnd
                            );
                            await navigator.clipboard.writeText(selectedText);
                            showSuccessInUI('選択テキストをコピーしました');
                        } else {
                            await navigator.clipboard.writeText(activeElement.value);
                            showSuccessInUI('全文をコピーしました');
                        }
                    }
                } catch (error) {
                    console.error('コピーエラー:', error);
                    showErrorInUI('コピーに失敗しました');
                }
            }

            async pasteToSelectedElement() {
                try {
                    const text = await navigator.clipboard.readText();
                    const activeElement = document.activeElement;

                    if (this.isTextAreaFocused()) {
                        const start = activeElement.selectionStart;
                        const end = activeElement.selectionEnd;
                        const value = activeElement.value;

                        const newValue = value.substring(0, start) + text + value.substring(end);
                        activeElement.value = newValue;

                        const newCursorPos = start + text.length;
                        activeElement.setSelectionRange(newCursorPos, newCursorPos);

                        activeElement.dispatchEvent(new Event('input', { bubbles: true }));

                        showSuccessInUI('貼り付けました');
                    }
                } catch (error) {
                    console.error('貼り付けエラー:', error);
                    showErrorInUI('貼り付けに失敗しました');
                }
            }

            previousScenario() {
                try {
                    if (app && app.navigateToPreviousScenario) {
                        app.navigateToPreviousScenario();
                    }
                } catch (error) {
                    console.error('前のシナリオ移動エラー:', error);
                }
            }

            nextScenario() {
                try {
                    if (app && app.navigateToNextScenario) {
                        app.navigateToNextScenario();
                    }
                } catch (error) {
                    console.error('次のシナリオ移動エラー:', error);
                }
            }

            goToTop() {
                try {
                    window.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });

                    if (app && app.selectScenario) {
                        app.selectScenario('scenario1');
                    }
                } catch (error) {
                    console.error('トップ移動エラー:', error);
                }
            }

            toggleDarkMode() {
                try {
                    if (app && app.themeManager) {
                        app.themeManager.toggleTheme();
                    }
                } catch (error) {
                    console.error('ダークモード切り替えエラー:', error);
                }
            }

            toggleHistory() {
                try {
                    const historyPanel = safeGetElement('history-sidebar');
                    if (!historyPanel) return;

                    const isOpen = historyPanel.style.right === '0px';

                    if (isOpen) {
                        if (app && app.closeHistoryPanel) {
                            app.closeHistoryPanel();
                        }
                    } else {
                        if (app && app.openHistoryPanel) {
                            app.openHistoryPanel();
                        }
                    }
                } catch (error) {
                    console.error('履歴パネル切り替えエラー:', error);
                }
            }

            addNewScenario() {
                try {
                    if (app && app.scenarioManager) {
                        app.scenarioManager.addScenario(app.dataManager.currentCurrency);
                    }
                } catch (error) {
                    console.error('シナリオ追加エラー:', error);
                }
            }

            closeModals() {
                try {
                    const historyPanel = safeGetElement('history-sidebar');
                    if (historyPanel && historyPanel.style.right === '0px') {
                        if (app && app.closeHistoryPanel) {
                            app.closeHistoryPanel();
                        }
                        return;
                    }

                    const modals = document.querySelectorAll('.modal');
                    modals.forEach(modal => {
                        if (modal.style.display !== 'none') {
                            modal.remove();
                        }
                    });

                    hideError();

                } catch (error) {
                    console.error('モーダル閉じるエラー:', error);
                }
            }

            showHelp() {
                try {
                    const helpModal = safeGetElement('shortcut-help-modal');
                    if (helpModal) {
                        helpModal.style.display = 'flex';
                    }
                } catch (error) {
                    console.error('ヘルプ表示エラー:', error);
                }
            }

            createHelpModal() {
                try {
                    const modal = document.createElement('div');
                    modal.id = 'shortcut-help-modal';
                    modal.style.cssText = 'position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 2000; display: none; align-items: center; justify-content: center;';

                    const shortcuts = Array.from(this.shortcuts.entries())
                        .map(([key, shortcut]) => `
                            <tr>
                                <td style="padding: 8px; border-bottom: 1px solid #ddd; font-family: monospace; background: #f8f9fa;">${key}</td>
                                <td style="padding: 8px; border-bottom: 1px solid #ddd;">${shortcut.description}</td>
                            </tr>
                        `).join('');

                    modal.innerHTML = `
                        <div style="background: white; padding: 30px; border-radius: 8px; max-width: 600px; max-height: 80vh; overflow-y: auto; margin: 20px;">
                            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                                <h2 style="margin: 0; color: #333;">キーボードショートカット</h2>
                                <button onclick="this.closest('#shortcut-help-modal').style.display='none'" style="background: none; border: none; font-size: 24px; cursor: pointer; color: #666;">×</button>
                            </div>
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="background: #f8f9fa;">
                                        <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">キー</th>
                                        <th style="padding: 12px; text-align: left; border-bottom: 2px solid #ddd;">機能</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    ${shortcuts}
                                </tbody>
                            </table>
                            <div style="margin-top: 20px; padding: 15px; background: #e9ecef; border-radius: 5px; font-size: 14px; color: #666;">
                                <strong>注意:</strong> 入力欄にフォーカスがある場合、一部のショートカットは動作しません。
                            </div>
                        </div>
                    `;

                    document.body.appendChild(modal);

                    modal.addEventListener('click', (e) => {
                        if (e.target === modal) {
                            modal.style.display = 'none';
                        }
                    });

                } catch (error) {
                    console.error('ヘルプモーダル作成エラー:', error);
                }
            }

            setEnabled(enabled) {
                this.isEnabled = enabled;
                console.log(`キーボードショートカット: ${enabled ? '有効' : '無効'}`);
            }
        }

        // メインアプリケーションクラス
        class FXAnalysisApp {
            constructor() {
                this.supabase = null;
                this.dataManager = null;
                this.scenarioManager = null;
                this.historyManager = null;
                this.backupManager = null;
                this.themeManager = null;
                this.usageMonitor = null;
                this.keyboardShortcuts = null;
                this.eventManager = new EventManager();
                this.offlineManager = new OfflineManager();
                this.errorMonitor = new ErrorMonitor();
                this.isInitialized = false;
            }

            async initialize() {
                if (isInitializing) {
                    console.warn('初期化が既に実行中です');
                    return;
                }

                isInitializing = true;

                try {
                    console.log('FX Analysis System 初期化開始');

                    await waitForSupabase();

                    this.supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

                    const connectionTest = await safeSupabaseOperation(
                        () => this.supabase.from('fx_analysis_data').select('count', { count: 'exact', head: true }),
                        'Supabase接続テスト',
                        3
                    );

                    if (!connectionTest.success) {
                        throw new Error('Supabaseに接続できません。ネットワーク接続を確認してください。');
                    }

                    console.log('Supabase接続成功');

                    this.dataManager = new DataManager(this.supabase);
                    this.scenarioManager = new ScenarioManager(this.dataManager);
                    this.historyManager = new HistoryManager(this.supabase);
                    this.backupManager = new BackupManager(this.supabase);
                    this.themeManager = new ThemeManager(this.dataManager);
                    this.usageMonitor = new UsageMonitor(this.supabase);
                    this.keyboardShortcuts = new KeyboardShortcuts(this.dataManager);

                    await this.initializeUI();
                    this.setupEventListeners();
                    await this.loadInitialData();

                    window.historyManager = this.historyManager;

                    this.isInitialized = true;
                    console.log('FX Analysis System 初期化完了');

                    showSuccessInUI('システムが正常に初期化されました');

                } catch (error) {
                    console.error('初期化エラー:', error);
                    this.showFallbackUI(error);
                } finally {
                    isInitializing = false;
                }
            }

            async initializeUI() {
                try {
                    this.initHistoryPanel();
                    await this.updateCurrentDisplay();
                    this.initProgressBars();

                    console.log('UI初期化完了');

                } catch (error) {
                    console.error('UI初期化エラー:', error);
                }
            }

            initProgressBars() {
                try {
                    const dbProgress = safeGetElement('db-usage');
                    const storageProgress = safeGetElement('storage-usage');

                    if (dbProgress) {
                        dbProgress.value = 0;
                        dbProgress.max = 100;
                    }

                    if (storageProgress) {
                        storageProgress.value = 0;
                        storageProgress.max = 100;
                    }

                } catch (error) {
                    console.error('プログレスバー初期化エラー:', error);
                }
            }

            initHistoryPanel() {
                try {
                    const historyPanel = safeGetElement('history-sidebar');
                    if (historyPanel) {
                        historyPanel.style.right = '-400px';
                    }
                } catch (error) {
                    console.error('履歴パネル初期化エラー:', error);
                }
            }

            setupEventListeners() {
                try {
                    document.querySelectorAll('.currency-btn').forEach(btn => {
                        this.eventManager.addListener(btn, 'click', (e) => {
                            this.selectCurrency(e.target.dataset.currency);
                        });
                    });

                    document.querySelectorAll('.status-btn').forEach(btn => {
                        this.eventManager.addListener(btn, 'click', (e) => {
                            this.selectAnalysisStatus(e.target.dataset.status);
                        });
                    });

                    document.querySelectorAll('.wave-btn').forEach(btn => {
                        this.eventManager.addListener(btn, 'click', (e) => {
                            this.selectTargetWave(e.target.dataset.wave);
                        });
                    });

                    const memoElement = safeGetElement('analysis-memo');
                    if (memoElement) {
                        this.eventManager.addListener(memoElement, 'input', 
                            this.debounce((e) => {
                                this.dataManager.autoSave(
                                    this.dataManager.currentCurrency,
                                    this.dataManager.currentScenario,
                                    'memo',
                                    e.target.value
                                );
                            }, 1000)
                        );
                    }

                    const promptElement = safeGetElement('fixed-prompt');
                    if (promptElement) {
                        this.eventManager.addListener(promptElement, 'input',
                            this.debounce((e) => {
                                this.dataManager.autoSave('global', 'settings', 'fixedPrompt', e.target.value);
                            }, 1000)
                        );
                    }

                    this.setupButtonListeners();
                    this.setupNavigationListeners();
                    this.setupHistoryListeners();
                    this.setupCopyListeners();
                    this.setupErrorBarListeners();

                    console.log('イベントリスナー設定完了');

                } catch (error) {
                    console.error('イベントリスナー設定エラー:', error);
                }
            }

            setupButtonListeners() {
                const backupBtn = safeGetElement('backup-btn');
                if (backupBtn) {
                    this.eventManager.addListener(backupBtn, 'click', () => {
                        this.backupManager.createBackup();
                    });
                }

                const themeToggle = safeGetElement('theme-toggle');
                if (themeToggle) {
                    this.eventManager.addListener(themeToggle, 'click', () => {
                        this.themeManager.toggleTheme();
                    });
                }

                const addScenarioBtn = safeGetElement('add-scenario');
                if (addScenarioBtn) {
                    this.eventManager.addListener(addScenarioBtn, 'click', () => {
                        this.scenarioManager.addScenario(this.dataManager.currentCurrency);
                    });
                }

                const removeScenarioBtn = safeGetElement('remove-scenario');
                if (removeScenarioBtn) {
                    this.eventManager.addListener(removeScenarioBtn, 'click', () => {
                        this.scenarioManager.deleteScenario(
                            this.dataManager.currentCurrency,
                            this.dataManager.currentScenario
                        );
                    });
                }

                const addCurrencyBtn = safeGetElement('add-currency');
                if (addCurrencyBtn) {
                    this.eventManager.addListener(addCurrencyBtn, 'click', () => {
                        this.addCurrency();
                    });
                }

                const removeCurrencyBtn = safeGetElement('remove-currency');
                if (removeCurrencyBtn) {
                    this.eventManager.addListener(removeCurrencyBtn, 'click', () => {
                        this.removeCurrency();
                    });
                }
            }

            setupNavigationListeners() {
                const prevBtn = safeGetElement('prev-chart');
                if (prevBtn) {
                    this.eventManager.addListener(prevBtn, 'click', () => {
                        this.navigateToPreviousScenario();
                    });
                }

                const nextBtn = safeGetElement('next-chart');
                if (nextBtn) {
                    this.eventManager.addListener(nextBtn, 'click', () => {
                        this.navigateToNextScenario();
                    });
                }

                const topBtn = safeGetElement('top-return');
                if (topBtn) {
                    this.eventManager.addListener(topBtn, 'click', () => {
                        this.returnToTop();
                    });
                }
            }

            setupHistoryListeners() {
                const historyBtn = safeGetElement('history-btn');
                if (historyBtn) {
                    this.eventManager.addListener(historyBtn, 'click', () => {
                        this.openHistoryPanel();
                    });
                }

                const closeHistoryBtn = safeGetElement('close-history');
                if (closeHistoryBtn) {
                    this.eventManager.addListener(closeHistoryBtn, 'click', () => {
                        this.closeHistoryPanel();
                    });
                }

                const historySearchInput = safeGetElement('history-search');
                if (historySearchInput) {
                    this.eventManager.addListener(historySearchInput, 'input',
                        this.debounce((e) => {
                            this.historyManager.searchHistory(e.target.value);
                        }, 500)
                    );
                }
            }

            setupCopyListeners() {
                const copyMemoBtn = safeGetElement('copy-memo');
                if (copyMemoBtn) {
                    this.eventManager.addListener(copyMemoBtn, 'click', () => {
                        const memo = safeGetElement('analysis-memo')?.value || '';
                        this.copyToClipboard(memo);
                    });
                }

                const copyPromptBtn = safeGetElement('copy-prompt');
                if (copyPromptBtn) {
                    this.eventManager.addListener(copyPromptBtn, 'click', () => {
                        const prompt = safeGetElement('fixed-prompt')?.value || '';
                        this.copyToClipboard(prompt);
                    });
                }

                const changePromptBtn = safeGetElement('change-prompt');
                if (changePromptBtn) {
                    this.eventManager.addListener(changePromptBtn, 'click', () => {
                        this.changeFixedPrompt();
                    });
                }

                const chatgptBtn = safeGetElement('chatgpt-analysis');
                if (chatgptBtn) {
                    this.eventManager.addListener(chatgptBtn, 'click', () => {
                        this.openChatGPTAnalysis();
                    });
                }
            }

            setupErrorBarListeners() {
                const recoveryBtn = safeGetElement('recovery-btn');
                if (recoveryBtn) {
                    this.eventManager.addListener(recoveryBtn, 'click', () => {
                        hideError();
                    });
                }
            }

            debounce(func, wait) {
                let timeout;
                return function executedFunction(...args) {
                    const later = () => {
                        clearTimeout(timeout);
                        func(...args);
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(later, wait);
                };
            }

            async selectCurrency(currency) {
                try {
                    validateInput(currency, 'currency', true);

                    document.querySelectorAll('.currency-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.currency === currency);
                    });

                    this.dataManager.currentCurrency = currency;
                    await this.updateCurrentDisplay();

                    console.log(`通貨ペア選択: ${currency}`);

                } catch (error) {
                    console.error('通貨ペア選択エラー:', error);
                    showErrorInUI('通貨ペアの選択に失敗しました', error);
                }
            }

            async selectScenario(scenarioId) {
                try {
                    validateInput(scenarioId, 'scenario', true);

                    document.querySelectorAll('.scenario-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.scenario === scenarioId);
                    });

                    this.dataManager.currentScenario = scenarioId;
                    await this.updateCurrentDisplay();

                    console.log(`シナリオ選択: ${scenarioId}`);

                } catch (error) {
                    console.error('シナリオ選択エラー:', error);
                    showErrorInUI('シナリオの選択に失敗しました', error);
                }
            }

            async updateCurrentDisplay() {
                try {
                    const currency = this.dataManager.currentCurrency;
                    const scenario = this.dataManager.currentScenario;

                    safeUpdateElement('current-pair', currency);

                    const [memo, analysisStatus, targetWave] = await Promise.all([
                        this.dataManager.loadData(currency, scenario, 'memo'),
                        this.dataManager.loadData(currency, scenario, 'analysisStatus'),
                        this.dataManager.loadData(currency, scenario, 'targetWave')
                    ]);

                    const memoElement = safeGetElement('analysis-memo');
                    if (memoElement) {
                        memoElement.value = memo || '';
                    }

                    document.querySelectorAll('.status-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.status === analysisStatus);
                    });

                    document.querySelectorAll('.wave-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.wave === targetWave);
                    });

                    if (this.scenarioManager) {
                        await this.scenarioManager.displayScenarioImages(currency, scenario);
                    }

                    this.updateScenarioStatusDisplay(scenario, analysisStatus);

                    if (this.scenarioManager) {
                        await this.scenarioManager.updateScenarioUI(currency);
                    }

                    console.log(`表示更新完了: ${currency} - ${scenario}`);

                } catch (error) {
                    console.error('表示更新エラー:', error);
                    showErrorInUI('表示の更新に失敗しました', error);
                }
            }

            updateScenarioStatusDisplay(scenario, status) {
                try {
                    const scenarioBtn = document.querySelector(`[data-scenario="${scenario}"]`);
                    if (!scenarioBtn) return;

                    const statusIndicator = scenarioBtn.parentNode?.querySelector('.status-indicator');
                    if (statusIndicator && status) {
                        const statusEmoji = {
                            '検討中': '🤔',
                            '計算中': '🔄',
                            '実戦': '⚡',
                            '利確': '📈',
                            '損切り': '📉',
                            '見送り': '👀'
                        };
                        statusIndicator.textContent = `${statusEmoji[status] || '📊'} ${status}`;
                    }
                } catch (error) {
                    console.error('シナリオステータス表示更新エラー:', error);
                }
            }

            async selectAnalysisStatus(status) {
                try {
                    document.querySelectorAll('.status-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.status === status);
                    });

                    await this.dataManager.autoSave(
                        this.dataManager.currentCurrency,
                        this.dataManager.currentScenario,
                        'analysisStatus',
                        status
                    );

                    this.updateScenarioStatusDisplay(this.dataManager.currentScenario, status);

                    console.log(`分析ステータス選択: ${status}`);

                } catch (error) {
                    console.error('分析ステータス選択エラー:', error);
                    showErrorInUI('分析ステータスの選択に失敗しました', error);
                }
            }

            async selectTargetWave(wave) {
                try {
                    document.querySelectorAll('.wave-btn').forEach(btn => {
                        btn.classList.toggle('active', btn.dataset.wave === wave);
                    });

                    await this.dataManager.autoSave(
                        this.dataManager.currentCurrency,
                        this.dataManager.currentScenario,
                        'targetWave',
                        wave
                    );

                    console.log(`狙う波選択: ${wave}`);

                } catch (error) {
                    console.error('狙う波選択エラー:', error);
                    showErrorInUI('狙う波の選択に失敗しました', error);
                }
            }

            async addCurrency() {
                try {
                    const newCurrency = prompt('新しい通貨ペアを入力してください（例: EURJPY）:');
                    if (!newCurrency) return;

                    const currency = newCurrency.trim().toUpperCase();
                    validateInput(currency, 'currency', true);

                    const existingBtn = document.querySelector(`[data-currency="${currency}"]`);
                    if (existingBtn) {
                        showErrorInUI('この通貨ペアは既に存在します');
                        return;
                    }

                    const currencyButtons = document.querySelector('.currency-buttons');
                    if (currencyButtons) {
                        const newBtn = document.createElement('button');
                        newBtn.className = 'currency-btn';
                        newBtn.dataset.currency = currency;
                        newBtn.textContent = currency;
                        newBtn.style.cssText = 'background-color: #6c757d; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; min-width: 80px; transition: all 0.2s;';

                        this.eventManager.addListener(newBtn, 'click', (e) => {
                            this.selectCurrency(e.target.dataset.currency);
                        });

                        currencyButtons.appendChild(newBtn);

                        showSuccessInUI(`通貨ペア「${currency}」を追加しました`);
                        console.log(`通貨ペア追加: ${currency}`);
                    }

                } catch (error) {
                    console.error('通貨ペア追加エラー:', error);
                    showErrorInUI('通貨ペアの追加に失敗しました', error);
                }
            }

            async removeCurrency() {
                try {
                    const currentCurrency = this.dataManager.currentCurrency;

                    const defaultCurrencies = ['USDJPY', 'EURUSD', 'GBPUSD', 'AUDUSD', 'SILVER', 'GOLD'];
                    if (defaultCurrencies.includes(currentCurrency)) {
                        showErrorInUI('デフォルト通貨ペアは削除できません');
                        return;
                    }

                    if (!confirm(`通貨ペア「${currentCurrency}」を削除しますか？\n関連するすべてのデータが削除されます。\nこの操作は取り消せません。`)) {
                        return;
                    }

                    const currencyBtn = document.querySelector(`[data-currency="${currentCurrency}"]`);
                    if (currencyBtn) {
                        currencyBtn.remove();
                    }

                    const firstBtn = document.querySelector('.currency-btn');
                    if (firstBtn) {
                        await this.selectCurrency(firstBtn.dataset.currency);
                    }

                    showSuccessInUI(`通貨ペア「${currentCurrency}」を削除しました`);
                    console.log(`通貨ペア削除: ${currentCurrency}`);

                } catch (error) {
                    console.error('通貨ペア削除エラー:', error);
                    showErrorInUI('通貨ペアの削除に失敗しました', error);
                }
            }

            async navigateToPreviousScenario() {
                try {
                    const scenarioButtons = document.querySelectorAll('.scenario-btn');
                    const currentIndex = Array.from(scenarioButtons).findIndex(btn => 
                        btn.classList.contains('active')
                    );

                    if (currentIndex > 0) {
                        const prevBtn = scenarioButtons[currentIndex - 1];
                        await this.selectScenario(prevBtn.dataset.scenario);
                    } else if (scenarioButtons.length > 0) {
                        const lastBtn = scenarioButtons[scenarioButtons.length - 1];
                        await this.selectScenario(lastBtn.dataset.scenario);
                    }
                } catch (error) {
                    console.error('前のシナリオ移動エラー:', error);
                }
            }

            async navigateToNextScenario() {
                try {
                    const scenarioButtons = document.querySelectorAll('.scenario-btn');
                    const currentIndex = Array.from(scenarioButtons).findIndex(btn => 
                        btn.classList.contains('active')
                    );

                    if (currentIndex < scenarioButtons.length - 1) {
                        const nextBtn = scenarioButtons[currentIndex + 1];
                        await this.selectScenario(nextBtn.dataset.scenario);
                    } else if (scenarioButtons.length > 0) {
                        const firstBtn = scenarioButtons[0];
                        await this.selectScenario(firstBtn.dataset.scenario);
                    }
                } catch (error) {
                    console.error('次のシナリオ移動エラー:', error);
                }
            }

            async returnToTop() {
                try {
                    window.scrollTo({
                        top: 0,
                        behavior: 'smooth'
                    });

                    await this.selectScenario('scenario1');
                } catch (error) {
                    console.error('トップ戻りエラー:', error);
                }
            }

            openHistoryPanel() {
                try {
                    const sidebar = safeGetElement('history-sidebar');
                    if (sidebar) {
                        sidebar.style.right = '0';
                        this.historyManager.searchHistory('');
                    }
                } catch (error) {
                    console.error('履歴パネル開くエラー:', error);
                }
            }

            closeHistoryPanel() {
                try {
                    const sidebar = safeGetElement('history-sidebar');
                    if (sidebar) {
                        sidebar.style.right = '-400px';
                    }
                } catch (error) {
                    console.error('履歴パネル閉じるエラー:', error);
                }
            }

            async copyToClipboard(text) {
                try {
                    await navigator.clipboard.writeText(text);
                    showSuccessInUI('クリップボードにコピーしました');
                } catch (error) {
                    console.error('クリップボードコピーエラー:', error);
                    showErrorInUI('コピーに失敗しました');
                }
            }

            async changeFixedPrompt() {
                try {
                    const currentPrompt = safeGetElement('fixed-prompt')?.value || '';
                    const newPrompt = prompt('固定プロンプトを入力してください:', currentPrompt);

                    if (newPrompt !== null) {
                        const promptElement = safeGetElement('fixed-prompt');
                        if (promptElement) {
                            promptElement.value = newPrompt;

                            await this.dataManager.autoSave('global', 'settings', 'fixedPrompt', newPrompt);

                            showSuccessInUI('固定プロンプトを更新しました');
                        }
                    }
                } catch (error) {
                    console.error('固定プロンプト変更エラー:', error);
                    showErrorInUI('固定プロンプトの変更に失敗しました', error);
                }
            }

            openChatGPTAnalysis() {
                try {
                    const memo = safeGetElement('analysis-memo')?.value || '';
                    const prompt = safeGetElement('fixed-prompt')?.value || '';

                    const analysisText = prompt + '\n\n' + memo;

                    const chatgptUrl = 'https://chat.openai.com/';
                    const newWindow = window.open(chatgptUrl, '_blank');

                    if (newWindow) {
                        this.copyToClipboard(analysisText);
                        showSuccessInUI('ChatGPTを開き、分析内容をクリップボードにコピーしました');
                    } else {
                        showErrorInUI('ポップアップがブロックされました。手動でChatGPTを開いてください。');
                    }

                } catch (error) {
                    console.error('ChatGPT分析開くエラー:', error);
                    showErrorInUI('ChatGPT分析の開始に失敗しました', error);
                }
            }

            async loadInitialData() {
                try {
                    const fixedPrompt = await this.dataManager.loadData('global', 'settings', 'fixedPrompt');
                    if (fixedPrompt) {
                        const promptElement = safeGetElement('fixed-prompt');
                        if (promptElement) {
                            promptElement.value = fixedPrompt;
                        }
                    }

                    await this.updateCurrentDisplay();

                    console.log('初期データ読み込み完了');

                } catch (error) {
                    console.error('初期データ読み込みエラー:', error);
                }
            }

            showFallbackUI(error) {
                document.body.innerHTML = `
                    <div style="text-align: center; padding: 50px; font-family: Arial, sans-serif; background: #f8f9fa; min-height: 100vh; display: flex; flex-direction: column; justify-content: center;">
                        <div style="max-width: 600px; margin: 0 auto; background: white; padding: 40px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.1);">
                            <h1 style="color: #dc3545; margin-bottom: 20px;">⚠️ システム初期化エラー</h1>
                            <p style="margin: 20px 0; font-size: 16px; line-height: 1.6; color: #333;">
                                ${sanitizeHTML(error.message)}
                            </p>
                            <div style="margin: 30px 0;">
                                <button onclick="location.reload()" style="padding: 12px 24px; margin: 8px; background: #007bff; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">
                                    🔄 再読み込み
                                </button>
                                <button onclick="clearLocalStorage()" style="padding: 12px 24px; margin: 8px; background: #dc3545; color: white; border: none; border-radius: 5px; cursor: pointer; font-size: 16px;">
                                    🗑️ データリセット
                                </button>
                            </div>
                            <details style="margin-top: 30px; text-align: left;">
                                <summary style="cursor: pointer; color: #666; font-size: 14px; margin-bottom: 10px;">🔧 技術詳細</summary>
                                <pre style="background: #f8f9fa; padding: 15px; border-radius: 5px; overflow: auto; font-size: 12px; color: #333; border: 1px solid #dee2e6;">${sanitizeHTML(error.stack || 'スタック情報なし')}</pre>
                            </details>
                            <div style="margin-top: 30px; padding: 15px; background: #e9ecef; border-radius: 5px; font-size: 14px; color: #666;">
                                <strong>対処法:</strong><br>
                                1. ページを再読み込みしてください<br>
                                2. 問題が続く場合はデータリセットを試してください<br>
                                3. ネットワーク接続を確認してください
                            </div>
                        </div>
                    </div>
                `;

                window.clearLocalStorage = () => {
                    if (confirm('すべてのローカルデータを削除しますか？\nこの操作は取り消せません。')) {
                        try {
                            localStorage.clear();
                            sessionStorage.clear();
                            location.reload();
                        } catch (err) {
                            alert('データの削除に失敗しました: ' + err.message);
                        }
                    }
                };
            }
        }

        // イベント管理クラス
        class EventManager {
            constructor() {
                this.boundEvents = new Map();
            }

            addListener(element, event, handler, options = {}) {
                if (!element) {
                    console.warn('イベントリスナー追加: 要素が見つかりません');
                    return;
                }

                const key = `${element.id || 'anonymous'}_${event}_${Date.now()}`;

                try {
                    element.addEventListener(event, handler, options);
                    this.boundEvents.set(key, { element, event, handler, options });
                } catch (error) {
                    console.error('イベントリスナー追加エラー:', error);
                }
            }

            removeAllListeners() {
                try {
                    for (const [key, { element, event, handler, options }] of this.boundEvents) {
                        element.removeEventListener(event, handler, options);
                    }
                    this.boundEvents.clear();
                    console.log('全イベントリスナー削除完了');
                } catch (error) {
                    console.error('イベントリスナー削除エラー:', error);
                }
            }
        }

        // オフライン管理クラス
        class OfflineManager {
            constructor() {
                this.isOnline = navigator.onLine;
                this.pendingOperations = [];
                this.init();
            }

            init() {
                window.addEventListener('online', () => {
                    this.isOnline = true;
                    this.hideOfflineMode();
                    this.syncPendingData();
                });

                window.addEventListener('offline', () => {
                    this.isOnline = false;
                    this.showOfflineMode();
                });
            }

            showOfflineMode() {
                showErrorInUI('オフラインモード: 表示のみ可能です。接続が復旧すると自動的に同期されます。');
            }

            hideOfflineMode() {
                hideError();
                showSuccessInUI('オンラインに復帰しました');
            }

            async syncPendingData() {
                if (this.pendingOperations.length === 0) return;

                console.log(`オフライン中の操作を同期中: ${this.pendingOperations.length}件`);

                for (const operation of this.pendingOperations) {
                    try {
                        await operation();
                    } catch (error) {
                        console.error('オフライン同期エラー:', error);
                    }
                }

                this.pendingOperations = [];
                showSuccessInUI('オフライン中のデータを同期しました');
            }

            addPendingOperation(operation) {
                this.pendingOperations.push(operation);
            }
        }

        // エラー監視クラス
        class ErrorMonitor {
            constructor() {
                this.errorCount = 0;
                this.errors = [];
                this.maxErrors = 50;
                this.init();
            }

            init() {
                window.addEventListener('error', (e) => {
                    this.logError('JavaScript Error', e.error || e.message, e.filename, e.lineno);
                });

                window.addEventListener('unhandledrejection', (e) => {
                    this.logError('Unhandled Promise Rejection', e.reason);
                });
            }

            logError(type, error, filename = '', lineno = 0) {
                this.errorCount++;

                const errorInfo = {
                    type,
                    message: error?.message || error,
                    stack: error?.stack,
                    filename,
                    lineno,
                    timestamp: new Date().toISOString(),
                    userAgent: navigator.userAgent,
                    url: window.location.href
                };

                this.errors.push(errorInfo);

                if (this.errors.length > this.maxErrors) {
                    this.errors.shift();
                }

                console.error('監視エラー:', errorInfo);

                if (this.errorCount > 10) {
                    showErrorInUI('システムエラーが多発しています。ページを再読み込みしてください。');
                }
            }

            getErrorReport() {
                return {
                    totalErrors: this.errorCount,
                    recentErrors: this.errors.slice(-10),
                    timestamp: new Date().toISOString()
                };
            }
        }

        // アプリケーション開始
        window.addEventListener('DOMContentLoaded', async function() {
            try {
                app = new FXAnalysisApp();
                await app.initialize();
            } catch (error) {
                console.error('アプリケーション開始エラー:', error);

                document.body.innerHTML = `
                    <div style="text-align: center; padding: 50px; color: red;">
                        <h1>システムエラー</h1>
                        <p>アプリケーションの初期化に失敗しました。</p>
                        <button onclick="location.reload()">再読み込み</button>
                    </div>
                `;
            }
        });

        // ページ離脱時のクリーンアップ
        window.addEventListener('beforeunload', function() {
            try {
                if (app && app.eventManager) {
                    app.eventManager.removeAllListeners();
                }
            } catch (error) {
                console.error('クリーンアップエラー:', error);
            }
        });
    </script>
</body>
</html>
